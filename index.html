<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trellis</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- New Serif Font -->
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212;
            --tile-bg: #282828;
            --letter-bg: #404040;
            --text-color: #E0E0E0;
            --border-color: #555;

            /* --- Standard Hint Colors --- */
            --standard-hint-correct: #4CAF50; /* Green */
            --standard-hint-present: #F59E0B; /* Amber 500 */
            --standard-hint-incorrect: #EF4444; /* Red 500 */

            /* --- NEW: High Contrast Hint Colors --- */
            --hc-hint-correct: #4CAF50;  /* Green (Stays same) */
            --hc-hint-present: #2196F3;  /* Bright Blue */
            --hc-hint-incorrect: #EF4444; /* Red 500 (Stays same) */

            /* --- Active Hint Colors (default to standard) --- */
            --hint-correct: var(--standard-hint-correct);
            --hint-present: var(--standard-hint-present);
            --hint-incorrect: var(--standard-hint-incorrect);

            --selection-color: #2979FF; /* Blue */
             --unchecked-color: #555; /* Grey for emoji grid */
            --tile-size: clamp(35px, 6vmin, 50px);
            --gap: 4px;
             --flip-duration: 0.6s;
        }
        
        /* --- NEW: Apply High Contrast Colors --- */
        body.high-contrast {
            --hint-correct: var(--hc-hint-correct);
            --hint-present: var(--hc-hint-present);
            --hint-incorrect: var(--hc-hint-incorrect);
        }

        /* Light Mode Theme */
        body.light-mode {
            --bg-color: #F0F0F0;
            --tile-bg: #DCDCDC;
            --letter-bg: #FFFFFF;
            --text-color: #121212;
            --border-color: #AAAAAA;
            
            /* -- Standard Light Mode Hints -- */
            --standard-hint-correct: #4CAF50;
            --standard-hint-present: #F59E0B;
            --standard-hint-incorrect: #DC2626; /* Darker Red for light bg */

            /* -- HC Light Mode Hints -- */
            --hc-hint-correct: #4CAF50;
            --hc-hint-present: #2196F3; /* Same Blue */
            --hc-hint-incorrect: #DC2626; /* Same Darker Red */

            --unchecked-color: #AAAAAA;
        }

        /* --- NEW: Apply High Contrast (Light Mode) --- */
        /* This ensures the light-mode specific red is still used */
        body.light-mode.high-contrast {
             --hint-correct: var(--hc-hint-correct);
             --hint-present: var(--hc-hint-present);
             --hint-incorrect: var(--hc-hint-incorrect);
        }

        body {
            /* Changed Font */
            font-family: 'Lora', serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
            /* --- NEW: Perspective for 3D flip --- */
            perspective: 1000px;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            padding: 1rem;
            position: relative;
            max-width: 95vw;
        }
        h1 {
            font-size: 2.5rem;
            margin: 0;
            /* Changed to solid color */
            color: var(--selection-color);
        }
        .header-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
            width: 100%;
        }
        .check-lights { display: flex; gap: 6px; }
        .check-light {
            width: 25px; height: 10px; border-radius: 5px;
            background-color: var(--hint-correct);
        }
        .check-light.used { background-color: var(--hint-incorrect); }

        /* Icon Buttons */
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-color);
            opacity: 0.7;
            transition: opacity 0.2s, color 0.2s; /* Added color transition */
        }
        .icon-btn:hover {
            opacity: 1;
            color: var(--selection-color); /* Hover blue */
        }
        .icon-btn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* Standard Buttons */
        #check-btn, #practice-btn {
            background-color: var(--hint-correct); /* New rest state: green */
            color: #FFFFFF; /* White text for contrast */
            border: 1px solid var(--hint-correct);
            padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            font-family: 'Inter', sans-serif; /* Keep buttons sans-serif for readability */
            font-weight: 700;
            box-sizing: border-box; /* Ensure padding is included */
            height: 50px; /* Explicit height */
        }
        /* Special Buttons */
        #share-btn, #play-btn {
            background-color: var(--selection-color); /* Rest state: blue */
            color: #FFFFFF;
            border: 1px solid var(--selection-color);
            padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            font-family: 'Inter', sans-serif;
            font-weight: 700;
        }

        /* Hover States */
        #check-btn:hover, #practice-btn:hover {
            background-color: var(--selection-color); /* Hover state: blue */
            border-color: var(--selection-color);
        }
         #share-btn:hover, #play-btn:hover {
            background-color: var(--hint-correct); /* Hover state: green */
            border-color: var(--hint-correct);
         }

        #check-btn:disabled, #play-btn:disabled {
            background-color: #282828;
            border-color: #282828;
            color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }

        #header-move-counter {
            background-color: var(--hint-incorrect);
            color: #FFFFFF;
            border: 1px solid var(--hint-incorrect);
            border-radius: 8px;
            padding: 0.5rem 1rem; /* Match check button padding */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box; /* Ensure padding is included in size */
            height: 50px; /* Explicit height */
            line-height: 1.1; /* Adjust line height */
        }
        #header-move-counter span {
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            font-size: 0.7rem; /* Smaller font */
            color: #F0F0F0;
            opacity: 0.8;
        }
         #header-move-counter #move-count-text {
            font-family: 'Lora', serif;
            font-size: 1.2rem; /* Smaller font */
            color: #FFFFFF;
            opacity: 1;
         }

        .main-area {
            display: flex;
            flex-direction: column; /* Stack grid and tray */
            align-items: center;
            gap: 1.5rem;
            width: 100%;
        }
        .puzzle-grid { display: flex; flex-direction: column; gap: var(--gap); }
        .grid-row {
            display: grid;
            grid-template-columns: repeat(7, var(--tile-size)); /* 7 Columns */
            gap: var(--gap);
        }
        .grid-tile, .tray-tile, .placeholder-tile {
            width: var(--tile-size); height: var(--tile-size);
            display: flex; justify-content: center; align-items: center;
            border-radius: 6px;
        }
        .grid-tile { background-color: var(--tile-bg); border: 1px solid var(--border-color); }
        .placeholder-tile { background-color: transparent; border: none; }
        .grid-tile.stem-letter {
            transition: background-color 0.5s, border-color 0.5s;
            border: 1px solid var(--selection-color);
        }
        .grid-tile.stem-win, .grid-tile.stem-win .letter-tile {
            background-color: var(--selection-color);
            color: #FFF; /* Ensure white text */
            border-color: var(--selection-color); /* Ensure border matches */
        }
        .letter-tile {
            width: 90%; height: 90%; background-color: var(--letter-bg);
            border-radius: 4px; font-size: calc(var(--tile-size) * 0.5); font-weight: 700;
            cursor: pointer; user-select: none;
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s; /* Existing transitions */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex; justify-content: center; align-items: center;
             /* --- NEW: For flip animation --- */
             transform-style: preserve-3d;
             backface-visibility: hidden; /* Hide back during flip */
        }
        .letter-tile.selected {
            box-shadow: 0 0 0 3px var(--selection-color);
            transform: scale(1.05);
        }
        .letter-tile.locked { cursor: not-allowed; }

        /* --- Tile Hint Styles (These now use the active --hint variables) --- */
        .letter-tile.hint-correct, .letter-tile.locked {
            background-color: var(--hint-correct);
            color: #FFFFFF;
        }
        .letter-tile.hint-present {
            background-color: var(--hint-present);
            color: #FFFFFF;
        }
        .letter-tile.hint-incorrect {
            background-color: var(--hint-incorrect);
            color: #FFFFFF;
        }

        /* --- NEW: Flip Animation --- */
        @keyframes flip {
            0% { transform: rotateX(0deg); background-color: var(--letter-bg); }
            50% { transform: rotateX(90deg); background-color: var(--letter-bg); } /* Color change happens via JS */
            100% { transform: rotateX(0deg); } /* Background is now the hint color */
        }

        .letter-tile.reveal {
             animation: flip var(--flip-duration) ease-in-out;
        }

        .letter-tray {
            display: flex;
            flex-direction: column; /* Stack rows */
            gap: var(--gap);
            background-color: #1f1f1f;
            padding: var(--gap);
            border-radius: 8px;
            width: auto;
        }
        body.light-mode .letter-tray {
             background-color: #CFCFCF;
        }
        .tray-row {
            display: grid;
            gap: var(--gap);
        }
        .tray-tile {
             background-color: transparent;
             border: none;
             padding: 0;
             width: var(--tile-size);
             height: var(--tile-size);
        }

        #message-area { font-size: 1.2rem; height: 1.5rem; color: var(--hint-correct); font-weight: bold; text-align: center; }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s;
        }
        body.light-mode .modal-overlay {
            background: rgba(255,255,255,0.7);
        }
        .modal-overlay.visible {
            display: flex;
            opacity: 1;
        }
        .modal-box {
            background-color: var(--tile-bg);
            padding: 1.5rem;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 1000;
            width: 85%;
            max-width: 450px;
            position: relative;
            transform: scale(0.95);
            transition: transform 0.3s;
        }
        .modal-overlay.visible .modal-box {
            transform: scale(1);
        }
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            opacity: 0.7;
        }
        .modal-close-btn:hover { opacity: 1; }
        .modal-close-btn svg { width: 24px; height: 24px; }

        /* End Game Stats Modal */
        #end-game-stats-modal h2 { margin-top: 0; color: var(--hint-correct); font-size: 1.8rem;}
        .end-game-stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin: 1.5rem 0; }
        .stat-item h3 { margin: 0; font-size: 1.5rem; font-family: 'Inter', sans-serif; }
        .stat-item p { margin: 0.2rem 0 0 0; color: #aaa; font-size: 0.8rem;}
        .stat-item.total-score h3 {
            color: var(--hint-present);
            font-size: 2.2rem;
            font-weight: 700;
        }
        .modal-buttons { display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;}

        /* Persistent Stats Modal Styles */
        #persistent-stats-modal h2 { text-align: center; margin-top: 0; color: var(--selection-color);}
        .persistent-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 columns */
            gap: 1rem;
            margin: 1.5rem 0;
            text-align: center;
        }
        .persistent-stat-item h3 {
            margin: 0;
            font-size: 1.8rem; /* Larger font */
            font-weight: 700;
            font-family: 'Inter', sans-serif;
            color: var(--hint-present); /* Highlight number */
        }
        .persistent-stat-item p {
            margin: 0.2rem 0 0 0;
            color: #aaa;
            font-size: 0.7rem; /* Smaller label */
            line-height: 1;
        }

        /* How to Play Styles */
        #help-modal { text-align: left; }
        #help-modal h2 { text-align: center; margin-top: 0; }
        #help-modal p { font-size: 0.9rem; color: var(--text-color); }
        .example-row { display: flex; gap: 4px; margin: 0.5rem 0; }
        .example-tile {
            width: 35px; height: 35px;
            display: flex; justify-content: center; align-items: center;
            font-weight: 700; font-size: 1rem;
            border-radius: 4px;
            color: #FFFFFF; /* All examples use white text for contrast */
            font-family: 'Inter', sans-serif;
        }
        .example-tile.stem {
             border: 1px solid var(--selection-color);
             width: 33px; height: 33px;
             background-color: var(--tile-bg);
             color: var(--text-color); /* Match theme text color */
        }
        .example-tile.correct { background-color: var(--hint-correct); }
        .example-tile.present { background-color: var(--hint-present); }
        .example-tile.incorrect { background-color: var(--hint-incorrect); }
        
        /* --- NEW: High Contrast Example Tiles --- */
        body.high-contrast .example-tile.present {
            background-color: var(--hc-hint-present);
        }
        body.high-contrast .example-tile.incorrect {
            background-color: var(--hc-hint-incorrect);
        }
        /* (Correct stays green) */


        /* Settings Modal Styles */
        #settings-modal h2 { text-align: center; margin-top: 0; }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        .setting-row:last-child { border-bottom: none; }
        .setting-row p { margin: 0; font-size: 1rem; }
        .toggle-switch {
            position: relative; display: inline-block;
            width: 50px; height: 28px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s; border-radius: 28px;
        }
        .slider:before {
            position: absolute; content: "";
            height: 20px; width: 20px; left: 4px; bottom: 4px;
            background-color: white; transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--selection-color); }
        input:checked + .slider:before { transform: translateX(22px); }

        /* Start Screen */
        #start-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--bg-color);
            z-index: 1001;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1.5rem; /* Reduced gap */
            transition: opacity 0.5s, visibility 0.5s;
        }
        .start-logo {
            width: 100px;
            height: 100px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 5px;
        }
        .logo-tile {
            border-radius: 4px;
        }
        .logo-stem { background-color: var(--selection-color); }
        .logo-leaf { background-color: var(--hint-correct); }
        .logo-leaf-alt { background-color: var(--hint-present); }

        #start-screen h1 { font-size: 3.5rem; }
        #tagline {
            font-family: 'Lora', serif; /* Use Lora serif font */
            font-size: 1rem;
            font-style: normal; /* Removed italic */
            color: #aaa;
            margin: -1rem 0 0 0;
            max-width: 90%;
            text-align: center;
        }
        body.light-mode #tagline {
            color: #555; /* Darker tagline for light mode */
        }

        #solution-display {
            margin-top: 1rem;
            padding: 0.5rem 1rem; /* Condensed padding */
            background-color: var(--tile-bg);
            border-radius: 8px;
            display: none;
            font-family: monospace;
            white-space: pre-line; /* Allows wrapping */
            text-align: left;
            border: 1px solid var(--border-color);
            font-size: 0.8rem; /* Smaller font */
            line-height: 1.3; /* Tighter line height */
            max-height: none; /* Remove fixed height */
        }
        #solution-display h3 {
            margin-top: 0.25rem; /* Tighter margin */
            margin-bottom: 0.25rem; /* Tighter margin */
            color: var(--hint-present);
            text-align: center;
        }
    </style>
</head>
<body>

    <!-- START SCREEN -->
    <div id="start-screen">
        <div class="start-logo">
            <div class="logo-tile"></div><div class="logo-tile logo-stem"></div><div class="logo-tile logo-leaf"></div>
            <div class="logo-tile logo-leaf-alt"></div><div class="logo-tile logo-stem"></div><div class="logo-tile"></div>
            <div class="logo-tile"></div><div class="logo-tile logo-stem"></div><div class="logo-tile logo-leaf"></div>
        </div>
        <h1>Trellis</h1>
        <p id="tagline"></p>
        <button id="play-btn">Play Daily</button>
    </div>

    <div class="game-container">
        <div class="header-controls">
            <button class="icon-btn" id="help-btn" aria-label="How to play"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></button>
            <button class="icon-btn" id="persistent-stats-btn" aria-label="Statistics"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 20v-6M6 20V10M18 20V4"></path></svg></button>
            <div class="check-lights" id="check-lights"></div>
            <button id="check-btn">Check</button>
            <div id="header-move-counter"><span>Moves</span><span id="move-count-text">0</span></div>
            <button class="icon-btn" id="settings-btn" aria-label="Settings"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></button>
        </div>
        <div class="main-area">
            <div class="puzzle-grid" id="puzzle-grid"></div>
            <div class="letter-tray" id="letter-tray"></div>
        </div>
        <div id="message-area"></div>

        <!-- End Game Stats Modal -->
        <div id="end-game-stats-modal-overlay" class="modal-overlay">
            <div id="end-game-stats-modal" class="modal-box">
                 <button class="icon-btn modal-close-btn" id="close-end-game-stats-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
                <h2 id="modal-title">Puzzle Solved!</h2>
                <div class="end-game-stats-grid">
                    <div class="stat-item"><h3 id="final-time">--:--</h3><p>Time</p></div>
                    <div class="stat-item"><h3 id="final-moves">--</h3><p>Moves</p></div>
                    <div class="stat-item"><h3 id="move-bonus">0</h3><p>Move Bonus</p></div>
                    <div class="stat-item"><h3 id="first-try-bonus">0</h3><p>First Try Bonus</p></div>
                    <div class="stat-item"><h3 id="check-bonus">0</h3><p>Checks Remaining Bonus</p></div>
                    <div class="stat-item total-score"><h3 id="final-score">0</h3><p>Total Score</p></div>
                </div>
                <div class="modal-buttons">
                    <button id="practice-btn">Practice</button>
                    <button id="share-btn">Share</button>
                </div>
            </div>
        </div>

        <!-- Persistent Stats Modal -->
        <div id="persistent-stats-modal-overlay" class="modal-overlay">
            <div id="persistent-stats-modal" class="modal-box">
                <button class="icon-btn modal-close-btn" id="close-persistent-stats-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
                <h2>Statistics</h2>
                <div class="persistent-stats-grid">
                    <div class="persistent-stat-item"><h3 id="stats-played">0</h3><p>Played</p></div>
                    <div class="persistent-stat-item"><h3 id="stats-win-pct">0</h3><p>Win %</p></div>
                    <div class="persistent-stat-item"><h3 id="stats-streak">0</h3><p>Current Streak</p></div>
                    <div class="persistent-stat-item"><h3 id="stats-max-streak">0</h3><p>Max Streak</p></div>
                </div>
            </div>
        </div>

        <!-- How to Play Modal -->
        <div id="help-modal-overlay" class="modal-overlay">
            <div id="help-modal" class="modal-box">
                <button class="icon-btn modal-close-btn" id="close-help-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
                <h2>How To Play</h2>
                <p>Use the letters from the tray to complete the words on the trellis.</p>
                <p>The central letters are part of the word. The word can be 4 letters long, and the stem letter can be in any position.</p>
                <div class="example-row"><div class="example-tile correct">W</div><div class="example-tile stem">A</div><div class="example-tile correct">L</div><div class="example-tile correct">L</div></div><p><b>Green:</b> Correct letter in the correct spot.</p>
                <div class="example-row"><div class="example-tile present">L</div><div class="example-tile stem">O</div><div class="example-tile incorrect">S</div><div class="example-tile present">T</div></div><p><b>Orange:</b> Correct letter in the wrong spot.</p>
                <div class="example-row"><div class="example-tile incorrect">B</div><div class="example-tile stem">R</div><div class="example-tile incorrect">I</div><div class="example-tile incorrect">G</div></div><p><b>Red:</b> Letter is not in the word.</p>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal-overlay" class="modal-overlay">
             <div id="settings-modal" class="modal-box">
                 <button class="icon-btn modal-close-btn" id="close-settings-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
                <h2>Settings</h2>
                <div class="setting-row">
                    <p>Dark Mode</p>
                    <label class="toggle-switch">
                        <input type="checkbox" id="theme-toggle"> <!-- Removed checked -->
                        <span class="slider"></span>
                    </label>
                </div>
                <!-- --- NEW: High Contrast Toggle --- -->
                <div class="setting-row">
                    <p>High Contrast Mode</p>
                    <label class="toggle-switch">
                        <input type="checkbox" id="contrast-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                 <div class="setting-row">
                    <p>Reset Daily Puzzle</p>
                    <button id="reset-daily-btn" style="background-color: var(--hint-incorrect); color: white; border: none; padding: 0.5rem; border-radius: 4px; cursor: pointer;">Reset Progress</button>
                </div>
            </div>
        </div>

        <!-- Solution display area -->
        <div id="solution-display">
             <h3>Solution:</h3>
             <div id="solution-text"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        const ALL_WORDS = ["ABLE","ACID","AGED","ALSO","AQUA","AREA","ARMY","AWAY","BABY","BACK","BAIL","BAIT","BALD","BALL","BALM","BAND","BANK","BARK","BARN","BASE","BASH","BASK","BATH","BEAD","BEAK","BEAM","BEAN","BEAR","BEAT","BEEF","BEEN","BEEP","BEER","BEET","BELL","BELT","BEND","BENT","BEST","BIKE","BILL","BIND","BIRD","BITE","BLEW","BLOB","BLOT","BLUE","BOAR","BOAT","BODY","BOIL","BOLD","BOLT","BOMB","BONE","BOOK","BOOM","BOOT","BORE","BORN","BOSS","BOTH","BOWL","BRED","BREW","BRIM","BUCK","BULB","BULK","BUMP","BUNK","BUOY","BURN","BURY","BUSH","BUSY","CAFE","CAGE","CAKE","CALF","CALL","CALM","CAME","CAMP","CANE","CAPE","CARB","CARD","CARE","CARP","CART","CASE","CASH","CASK","CAST","CELL","CENT","CHAT","CHIC","CHIN","CHIP","CHUM","CITE","CITY","CLAM","CLAN","CLAP","CLAW","CLAY","CLIP","CLOG","CLOT","CLUB","COAL","COAT","COCO","CODA","CODE","COIL","COIN","COKE","COLA","COLD","COMB","COME","CONE","COOK","COOL","COOP","COPY","CORD","CORE","CORK","CORN","COST","COVE","COZY","CRAB","CREW","CRIB","CROP","CROW","CULT","CURB","CURD","CURE","CURL","DAFT","DAME","DAMP","DANK","DARE","DARK","DART","DASH","DATA","DATE","DAWN","DAYS","DAZE","DEAD","DEAF","DEAL","DEAR","DEBT","DECK","DEED","DEEM","DEEP","DEER","DEFY","DELI","DENY","DESK","DIAL","DICE","DIET","DIRT","DISK","DOES","DOLE","DOME","DONE","DOOM","DOOR","DOSE","DOTE","DOWN","DOZE","DRAB","DRAG","DRAW","DREW","DROP","DRUG","DRUM","DUCK","DUEL","DUET","DUKE","DULL","DUNK","DUSK","DUST","DUTY","EACH","EARL","EARN","EASE","EAST","EASY","ECHO","EDGE","EDIT","ELSE","EVEN","EVER","EVIL","EXIT","FACE","FACT","FAIL","FAIR","FALL","FARM","FAST","FATE","FEAR","FEED","FEEL","FEET","FELL","FELT","FILE","FILL","FILM","FIND","FINE","FIRE","FIRM","FISH","FIVE","FLAG","FLAT","FLEW","FLIP","FLOW","FOAL","FOAM","FOIL","FOLD","FOLK","FOOD","FOOT","FORK","FORM","FORT","FOUR","FREE","FROM","FUEL","FULL","FUND","GAIN","GAME","GANG","GATE","GAVE","GEAR","GEEK","GENE","GIFT","GIRL","GIVE","GLAD","GOAL","GOAT","GOES","GOLD","GOLF","GONE","GOOD","GORE","GORY","GOUT","GOWN","GREW","GREY","GRID","GRIM","GRIN","GRIP","GROW","GULF","GUSH","GUST","HAIL","HAIR","HALF","HALL","HALO","HALT","HAND","HANG","HARD","HARM","HATE","HAVE","HAWK","HAZE","HAZY","HEAD","HEAL","HEAP","HEAR","HEAT","HEEL","HEIR","HELD","HELP","HERB","HERD","HERE","HERO","HIGH","HIKE","HILL","HINT","HIRE","HISS","HIVE","HOAX","HOLD","HOLE","HOLY","HOME","HONE","HOOF","HOOK","HOOP","HOPE","HORN","HOSE","HOST","HOUR","HUGE","HULK","HULL","HUNG","HUNT","HURT","IDEA","IDLE","IDOL","INCH","INTO","IRON","ITEM","JAIL","JADE","JAWS","JAZZ","JEEP","JELL","JERK","JEST","JINX","JOIN","JOKE","JOLT","JUMP","JUNK","JURY","JUST","KEEN","KEEP","KELP","KEPT","KICK","KILL","KIND","KING","KISS","KITE","KNEE","KNEW","KNOW","LACE","LACK","LADY","LAID","LAKE","LAMB","LAMP","LAND","LANE","LARK","LAST","LATE","LAVA","LAZY","LEAD","LEAF","LEAK","LEAN","LEAP","LEFT","LEND","LENT","LESS","LIFE","LIFT","LIKE","LIME","LINE","LINK","LINT","LION","LIST","LIVE","LOAD","LOAF","LOAN","LOCK","LOFT","LOGO","LONG","LOOK","LOOM","LOOP","LOOT","LORD","LOSE","LOSS","LOST","LOUD","LOVE","LUCK","LULL","LUMP","LUNG","LURE","LURK","LUSH","MADE","MAIL","MAIN","MAKE","MALE","MALL","MALT","MANE","MANY","MARK","MARS","MASK","MASS","MAST","MATE","MAUL","MAZE","MEAL","MEAN","MEAT","MEET","MELT","MEMO","MEND","MENU","MEOW","MESH","MESS","MILE","MILK","MILL","MIND","MINE","MINT","MISS","MIST","MITE","MOAN","MOAT","MODE","MOOD","MOON","MOOR","MOPE","MORE","MORN","MOST","MOTH","MOVE","MUCH","MUCK","MUDD","MUFF","MULE","MULL","MUST","MUTE","MUTT","MYTH","NAIL","NAME","NAVY","NEAR","NEAT","NECK","NEED","NERD","NEST","NEWS","NEXT","NICE","NIGH","NINE","NONE","NOOK","NOON","NORM","NOSE","NOTE","NOUN","NUDE","NUKE","NULL","NUMB","OATH","OATS","ODOR","OGRE","OILY","OINK","OKAY","OMEN","OMIT","ONCE","ONLY","ONTO","OOZE","OPEN","ORAL","OUCH","OUST","OVER","OWED","OWES","PACE","PACK","PAGE","PAID","PAIL","PAIN","PAIR","PALE","PALM","PANS","PANT","PAPA","PARK","PART","PASS","PAST","PATH","PAVE","PAWN","PEAK","PEAL","PEAR","PEAT","PECK","PEEK","PEEL","PEEP","PEER","PELT","PENT","PERK","PEST","PETS","PHEW","PICK","PILE","PILL","PIMP","PINE","PINK","PINT","PIPE","PITH","PIXY","PLAN","PLAY","PLEA","PLED","PLOT","PLOW","PLUG","PLUM","PLUS","POEM","POET","POKE","POKY","POLE","POLL","POLO","POND","PONY","POOL","POOR","POOF","POPE","PORK","PORT","POSE","POSH","POST","POUT","PRAY","PREP","PREY","PRIM","PROD","PROM","PROP","PROW","PUFF","PUKE","PULL","PULP","PUMA","PUMP","PUNK","PUNT","PUNY","PURE","PUSH","PUTT","PYRE","QUAD","QUAIL","QUAY","QUID","QUIP","QUIT","QUIZ","RACE","RACK","RAFT","RAGE","RAID","RAIL","RAIN","RAKE","RAMP","RANK","RANT","RARE","RASH","RATE","RAVE","RAYS","RAZE","READ","REAL","REAP","REAR","REEF","REEK","REEL","REIN","RELY","RENT","REST","RICE","RICH","RIDE","RIFT","RIND","RING","RINK","RINSE","RIPE","RISE","RISK","ROAD","ROAM","ROAR","ROBE","ROCK","RODE","ROLE","ROLL","ROOF","ROOM","ROOT","ROPE","ROSE","ROSY","ROTO","ROUT","ROVE","RUDE","RUIN","RULE","RUNG","RUNT","RUSE","RUSH","RUSK","RUST","RUTH","SACK","SAFE","SAGA","SAGE","SAGO","SAID","SAIL","SALE","SALT","SAME","SAND","SANE","SANK","SARI","SASH","SAWN","SCAB","SCAM","SCAN","SCAR","SCAT","SCOT","SCOW","SCUM","SEAL","SEAM","SEAR","SEAT","SECT","SEED","SEEK","SEEM","SEEN","SELF","SELL","SEND","SENT","SEPT","SERF","SETS","SEWN","SHAD","SHAG","SHAM","SHED","SHIN","SHIP","SHOE","SHOP","SHOT","SHOW","SHUN","SHUT","SICK","SIDE","SIFT","SIGN","SILK","SILL","SILO","SILT","SING","SINK","SITE","SIZE","SKEW","SKID","SKIM","SKIN","SKIP","SKIT","SLAB","SLAG","SLAM","SLAP","SLAT","SLAW","SLED","SLEW","SLID","SLIM","SLIP","SLIT","SLOB","SLOE","SLOG","SLOP","SLOT","SLOW","SLUG","SLUM","SLUR","SMOG","SMUG","SNAG","SNAP","SNIP","SNIT","SNOB","SNOW","SNUB","SNUG","SOAK","SOAP","SOAR","SOCK","SODA","SOFA","SOFT","SOIL","SOLD","SOLE","SOLO","SOME","SONG","SOON","SOOT","SORE","SORT","SOUL","SOUR","SOW","SPAM","SPAN","SPAR","SPAT","SPAY","SPEC","SPED","SPEW","SPIN","SPIT","SPOT","SPRY","SPUD","SPUN","SPUR","STAB","STAG","STAR","STAT","STAY","STEM","STEP","STEW","STIR","STOP","STOW","STUB","STUD","STUN","SUCH","SUCK","SUDS","SUIT","SULK","SUNK","SUNS","SURF","SUSHI","SWAB","SWAG","SWAM","SWAN","SWAP","SWAT","SWAY","SWIG","SWIM","SWUM","SYNC","TABS","TACO","TACT","TAIL","TAKE","TALC","TALE","TALK","TALL","TAME","TAMP","TANK","TAPE","TASK","TAUT","TAXI","TEAK","TEAL","TEAM","TEAR","TEAS","TEEN","TELL","TEND","TENT","TERM","TEST","TEXT","THAN","THAT","THAW","THEM","THEN","THIN","THIS","THUD","THUG","THUS","TICK","TIDE","TIDY","TIER","TIFF","TILE","TILT","TIME","TINT","TINY","TIRE","TOAD","TOGA","TOIL","TOLD","TOLL","TONE","TONG","TONS","TOOK","TOOL","TOOT","TORE","TORN","TOTE","TOUR","TOWN","TRAP","TRAY","TREE","TREK","TRIP","TROT","TRUE","TUBA","TUBE","TUCK","TUFT","TUNA","TUNE","TURF","TURK","TURN","TUSK","TUTU","TWEE","TWIG","TWIN","TWIT","TYPE","UNDO","UNIT","UPON","USED","USER","USES","VANE","VASE","VAST","VAULT","VEAL","VEIL","VEIN","VEND","VENT","VERY","VEST","VETO","VEXT","VIAL","VICE","VIEW","VINE","VISA","VISE","VOID","VOLT","VOTE","VOWS","WACK","WADE","WAFT","WAGE","WAIF","WAIL","WAIST","WAIT","WAKE","WALK","WALL","WAND","WANE","WANT","WARM","WARN","WARP","WARY","WASH","WASP","WAXY","WEAK","WEAL","WEAN","WEAR","WEED","WEEK","WEEP","WELD","WELL","WENT","WERE","WEST","WHAT","WHEN","WHIP","WIDE","WIFE","WILD","WILL","WILT","WILY","WIMP","WIND","WINE","WING","WINK","WINO","WIPE","WIRE","WIRY","WISE","WISH","WISP","WITH","WOKE","WOLF","WOMB","WONK","WOOD","WOOF","WOOL","WORD","WORE","WORK","WORM","WORN","WRAP","WREN","YANK","YYARD","YARN","YAWN","YEAR","YELL","YELP","YETI","YOGA","YOKE","YOLK","YORE","YOUR","ZANY","ZEAL","ZERO","ZEST","ZINC","ZING","ZIPS","ZONE","ZOOM"];
        const STEM_WORDS = ["ABILITY","ABOLISH","ABOVE","ABROAD","ABSENCE","ABSOLUTE","ABSORB","ABUSE","ACADEMIC","ACCEPTED","ACCESS","ACCIDENT","ACCOUNT","ACCURATE","ACHIEVE","ACQUIRE","ACROSS","ACTION","ACTIVE","ACTIVITY","ACTOR","ACTUAL","ADDRESS","ADJUST","ADMIRE","ADMIT","ADOPT","ADVANCE","ADVERSE","ADVICE","ADVISE","AFFAIRS","AFFECT","AFFORD","AFRAID","AGAINST","AGENCY","AGREE","AHEAD","AIRLINE","AIRPORT","ALARM","ALBUM","ALCOHOL","ALIKE","ALIVE","ALLOW","ALMOST","ALONE","ALONG","ALREADY","ALWAYS","AMAZING","AMONG","AMOUNT","ANALYZE","ANCIENT","ANGER","ANGLE","ANIMAL","ANNUAL","ANOTHER","ANSWER","ANXIETY","ANYBODY","ANYMORE","ANYONE","ANYTHING","ANYWAY","APART","APOLOGY","APPEAL","APPEAR","APPLY","APPROVE","AROUND","ARRANGE","ARREST","ARRIVAL","ARRIVE","ARTICLE","ASIDE","ASLEEP","ASSESS","ASSIST","ASSUME","ASSURE","ATMOSPHERE","ATTACH","ATTACK","ATTEMPT","ATTEND","ATTITUDE","ATTRACT","AUDIENCE","AUTHOR","AVERAGE","AVOID","AWARD","AWARE","AWFUL","BALANCE","BALLOON","BARRIER","BASIC","BASKET","BATTLE","BEACH","BEAST","BEAUTY","BECAUSE","BECOME","BEFORE","BEGIN","BEHALF","BEHAVE","BEHIND","BELIEF","BELIEVE","BELONG","BELOW","BENEFIT","BESIDE","BESIDES","BETWEEN","BEYOND","BICYCLE","BIGGEST","BILLION","BIRTH","BITTER","BLACK","BLAME","BLANKET","BLIND","BLOOD","BOARD","BOREDOM","BORDER","BORING","BORROW","BOTHER","BOTTOM","BRAIN","BRANCH","BRAVE","BREAD","BREAK","BREAST","BREATH","BREATHE","BRIDGE","BRIEF","BRIGHT","BRING","BROAD","BROTHER","BROWN","BRUSH","BUILD","BUILDING","BUNCH","BURDEN","BURN","BURST","BUSINESS","BUTTON","CABIN","CABINET","CABLE","CALCULATE","CAMERA","CAMPAIGN","CANCEL","CANCER","CANDIDATE","CANDLE","CAPABLE","CAPACITY","CAPITAL","CAPTAIN","CAPTURE","CARBON","CAREFUL","CAREER","CARPET","CARROT","CARRY","CARVE","CATCH","CATEGORY","CAUSE","CEILING","CELEBRATE","CENTER","CENTRAL","CENTURY","CEREMONY","CERTAIN","CHAIR","CHAIRMAN","CHALLENGE","CHAMBER","CHANCE","CHANGE","CHANNEL","CHAPTER","CHARACTER","CHARGE","CHARITY","CHARM","CHART","CHARTER","CHASE","CHEAP","CHEAT","CHECK","CHEEK","CHEER","CHEESE","CHEMICAL","CHERRY","CHEST","CHICKEN","CHIEF","CHILD","CHOICE","CHOOSE","CHUCKLE","CHURCH","CIRCLE","CIRCUIT","CITIZEN","CIVIL","CLAIM","CLASSIC","CLASSROOM","CLEAN","CLEAR","CLERK","CLICK","CLIENT","CLIMATE","CLIMB","CLOCK","CLOSE","CLOSET","CLOTHES","CLOUD","COACH","COAST","COFFEE","COLD","COLLECT","COLLEGE","COLONY","COLOR","COLUMN","COMBINE","COMEDY","COMFORT","COMMAND","COMMENT","COMMERCIAL","COMMIT","COMMON","COMMUNITY","COMPANY","COMPARE","COMPETE","COMPLETE","COMPLEX","COMPOSE","COMPUTER","CONCEPT","CONCERN","CONCERT","CONCLUDE","CONCRETE","CONDUCT","CONFIRM","CONFLICT","CONFUSE","CONNECT","CONSENT","CONSIST","CONSTANT","CONTACT","CONTAIN","CONTENT","CONTEST","CONTEXT","CONTINUE","CONTRACT","CONTROL","CONVERT","CONVINCE","COOKIE","CORNER","CORRECT","COSTLY","COULD","COUNCIL","COUNT","COUNTRY","COUPLE","COURAGE","COURSE","COURT","COVER","CRACK","CRAFT","CRASH","CRAZY","CREATE","CREATIVE","CREATURE","CREDIT","CRIME","CRIMINAL","CRISIS","CRITICAL","CRITICISM","CULTURE","CURIOUS","CURRENT","CURTAIN","CURVE","CUSTOMER","CYCLE","DANGER","DARKNESS","DAUGHTER","DEADLY","DEALER","DEBATE","DECADE","DECIDE","DECISION","DECLARE","DECREASE","DEEPLY","DEFAULT","DEFEAT","DEFEND","DEFENSE","DEFINE","DEGREE","DELAY","DELIVER","DEMAND","DEMOCRacy","DEPEND","DEPOSIT","DEPTH","DESCRIBE","DESERT","DESERVE","DESIGN","DESIRE","DESPITE","DESTROY","DETAIL","DETECT","DEVELOP","DEVICE","DEVOTE","DIAMOND","DIFFER","DIFFERENT","DIFFICULT","DIGITAL","DINNER","DIRECT","DIRECTION","DIRECTOR","DISASTER","DISCUSS","DISEASE","DISMISS","DISPLAY","DISTANCE","DISTANT","DISTRICT","DIVIDE","DIVISION","DOCTOR","DOCUMENT","DOMESTIC","DOMINATE","DOUBT","DRAIN","DRAMATIC","DRAWER","DRAWING","DREAM","DRESS","DRINK","DRIVE","DRIVER","DURING","DYNAMIC","EAGER","EARLY","EARTH","EASTERN","ECONOMY","EDITION","EDITOR","EDUCATE","EDUCATION","EFFECT","EFFECTIVE","EFFORT","EITHER","ELBOW","ELDERLY","ELECTION","ELECTRIC","ELEMENT","ELSEWHERE","EMERGENCY","EMOTION","EMPHASIS","EMPIRE","EMPLOY","EMPLOYEE","EMPLOYER","ENABLE","ENCOURAGE","ENEMY","ENERGY","ENGAGE","ENGINE","ENGINEER","ENJOY","ENORMOUS","ENOUGH","ENSURE","ENTER","ENTIRE","ENTRANCE","ENTRY","ENVIRONMENT","EPISODE","EQUAL","EQUALLY","EQUIPMENT","ESCAPE","ESSAY","ESSENTIAL","ESTABLISH","ESTATE","ESTIMATE","ETHICAL","EVALUATE","EVENING","EVENT","EVERY","EVERYBODY","EVERYONE","EVIDENCE","EXACTLY","EXAMPLE","EXAMINE","EXCEPT","EXCHANGE","EXCITED","EXCITING","EXCLUDE","EXCUSE","EXERCISE","EXHIBIT","EXIST","EXISTENCE","EXPAND","EXPECT","EXPENSE","EXPERIENCE","EXPERIMENT","EXPERT","EXPLAIN","EXPLODE","EXPLORE","EXPORT","EXPOSE","EXPRESS","EXTEND","EXTENT","EXTERNAL","EXTRA","EXTREME","FABRIC","FACTOR","FACTORY","FACULTY","FAILURE","FAINT","FAITH","FALSE","FAMILY","FAMOUS","FANCY","FANTASY","FARMER","Fashion","FATHER","FAULT","FAVOR","FAVORITE","FEATURE","FEDERAL","FEELING","FELLOW","FEMALE","FIBER","FICTION","FIELD","FIFTEEN","FIFTH","FIGHT","FIGHTER","FIGURE","FINAL","FINALLY","FINANCE","FINANCIAL","FINGER","FINISH","FIREMAN","FIRST","FISCAL","FISHING","FLAME","FLATTEN","FLAVOR","FLESH","FLIGHT","FLOAT","FLOOR","FLOWER","FLYING","FOCUS","FOLLOW","FOLLOWING","FOOTBALL","FORCE","FOREIGN","FOREST","FOREVER","FORGET","FORGIVE","FORMAL","FORMATION","FORMER","FORMULA","FORTH","FORTUNE","FORWARD","FOUND","FOUNDATION","FOURTH","FRAME","FRAMEWORK","FREEDOM","FREEZE","FREQUENCY","FREQUENT","FRESH","FRIEND","FRIENDLY","FRIGHTEN","FRONT","FROZEN","FRUIT","FUNCTION","FUNDING","FUNERAL","FURTHER","FUTURE","GALLERY","GARLIC","GATHER","GENERAL","GENERATE","GENEROUS","GENTLE","GENTLEMAN","GENUINE","GHOST","GIANT","GLOBAL","GLOVE","GOLDEN","GOVERNMENT","GOVERNOR","GRACEFUL","GRADE","GRADUAL","GRADUATE","GRAIN","GRAND","GRANDFATHER","GRANDMOTHER","GRANT","GRASS","GRAVITY","GREAT","GREATEST","GREEN","GROUND","GROUP","GROWING","GROWTH","GUARANTEE","GUARD","GUESS","GUEST","GUIDE","GUILTY","GUITAR","HABITAT","HANDFUL","HANDLE","HAPPEN","HAPPINESS","HAPPY","HARDLY","HEALTH","HEALTHY","HEARING","HEART","HEAVEN","HEAVILY","HEIGHT","HELICOPTER","HELPFUL","HERITAGE","HERSELF","HESITATE","HIDDEN","HIGHWAY","HIMSELF","HISTORIC","HISTORY","HOLIDAY","HOMELESS","HONESTY","HONOR","HORIZON","HORROR","HORSE","HOSPITAL","HOSTILE","HOTEL","HOUSE","HOUSEHOLD","HOUSING","HOWEVER","HUMAN","HUNDRED","HUNGRY","HUNTING","HUSBAND","IDENTIFY","IDENTITY","IGNORE","ILLEGAL","ILLNESS","IMAGE","IMAGINE","IMPACT","IMPLEMENT","IMPORTANCE","IMPORTANT","IMPOSE","IMPRESS","IMPROVE","INCLUDE","INCLUDING","INCOME","INCREASE","INDEED","INDEPENDENT","INDEX","INDICATE","INDIVIDUAL","INDUSTRY","INFLUENCE","INFORM","INITIAL","INITIALLY","INITIATIVE","INJURY","INNER","INNOCENT","INSIDE","INSIGHT","INSIST","INSPECT","INSPIRE","INSTALL","INSTANCE","INSTANT","INSTEAD","INSTITUTE","INSTRUCT","INSTRUMENT","INSURANCE","INTELLIGENCE","INTEND","INTENSE","INTENTION","INTEREST","INTERFERE","INTERNAL","INTERNATIONAL","INTERNET","INTERPRET","INTERVAL","INTERVIEW","INTO","INTRODUCE","INVENT","INVEST","INVESTIGATE","INVOLVE","ISLAND","ISSUE","ITSELF","JACKET","JEALOUS","JEWELRY","JOURNAL","JOURNEY","JUDGE","JUDGMENT","JUICE","JUSTICE","JUSTIFY","KEYBOARD","KITCHEN","KITTEN","KNOWING","KNOWLEDGE","LABOR","LACKING","LADDER","LANDING","LANDLORD","LANDSCAPE","LANGUAGE","LARGELY","LATELY","LATTER","LAUGH","LAUNCH","LAWYER","LAYER","LEADER","LEADERSHIP","LEADING","LEAGUE","LEARN","LEARNING","LEAST","LEAVE","LECTURE","LEGACY","LEGAL","LEGEND","LEISURE","LENGTH","LESSON","LETTER","LEVEL","LIBERAL","LIBERTY","LIBRARY","LICENSE","LIMITED","LINEAR","LINKING","LIQUID","LISTEN","LITERARY","LITERATURE","LITTLE","LIVING","LOADING","LOCAL","LOCATE","LOCATION","LOGGING","LOGICAL","LONELY","LONG-TERM","LONGER","LOUDLY","LOVELY","LOVING","LOWER","MACHINE","MAGAZINE","MAGIC","MAGNET","MAINLY","MAINTAIN","MAJOR","MAJORITY","MAKER","MANAGE","MANAGER","MANNER","MANUFACTURER","MARGIN","MARINE","MARKET","MARKETING","MARRIAGE","MARRIED","MASTER","MATCH","MATERIAL","MATTER","MAXIMUM","MAYBE","MEANING","MEANWHILE","MEASURE","MECHANISM","MEDICAL","MEDICINE","MEDIUM","MEETING","MEMBER","MEMORY","MENTAL","MENTION","MERELY","MESSAGE","METAL","METHOD","MIDDLE","MIDNIGHT","MIGHT","MILLION","MINDSET","MINERAL","MINIMUM","MINISTER","MINOR","MINORITY","MINUTE","MIRROR","MISSILE","MISSING","MISSION","MISTAKE","MIXED","MIXTURE","MOBILE","MODEL","MODERN","MODEST","MOMENT","MONDAY","MONEY","MONITOR","MONTH","MONTHLY","MORAL","MORNING","MORTGAGE","MOTHER","MOTION","MOTIVATE","MOTOR","MOUNTAIN","MOUSE","MOUTH","MOVEMENT","MOVIE","MUSCLE","MUSEUM","MUSIC","MUSICAL","MUSICIAN","MYSTERY","MYTHICAL","NARROW","NATION","NATIONAL","NATIVE","NATURAL","NATURE","NEARBY","NEARLY","NECESSARY","NECESSITY","NEGATIVE","NEIGHBOR","NEITHER","NERVOUS","NETWORK","NEUTRAL","NEVER","NEWSPAPER","NIGHT","NOBODY","NOISE","NORMAL","NORTH","NORTHERN","NOTHING","NOTICE","NOTION","NOWHERE","NUCLEAR","NUMBER","NUMEROUS","NURSERY","OBJECT","OBJECTIVE","OBSERVE","OBSERVER","OBTAIN","OBVIOUS","OCCASION","OCCUPY","OCEAN","OFFENCE","OFFEND","OFFER","OFFICE","OFFICER","OFFICIAL","OFTEN","ONGOING","ONION","ONLINE","OPENING","OPERATE","OPERATION","OPERATOR","OPINION","OPPONENT","OPPOSE","OPPOSITE","OPPOSITION","OPTION","ORDER","ORDINARY","ORGANIC","ORGANIZE","ORIGIN","ORIGINAL","OTHER","OURSELVES","OUTCOME","OUTDOOR","OUTER","OUTLET","OUTPUT","OUTSIDE","OXYGEN","PACKAGE","PAINT","PAINTER","PAINTING","PANEL","PAPER","PARENT","PARKING","PARTIAL","PARTICIPATE","PARTICULAR","PARTLY","PARTNER","PARTY","PASSAGE","PASSENGER","PASSION","PASSPORT","PASSWORD","PATIENT","PATTERN","PAUSE","PAYMENT","PEACE","PEACEFUL","PENALTY","PEOPLE","PEPPER","PERCEIVE","PERCENT","PERFECT","PERFORM","PERFORMANCE","PERHAPS","PERIOD","PERMIT","PERSON","PERSONAL","PERSUADE","PHASE","PHONE","PHOTO","PHOTOGRAPH","PHRASE","PHYSICAL","PIANO","PICKUP","PICTURE","PIECE","PILOT","PIZZA","PLACE","PLANET","PLANNING","PLANT","PLASTIC","PLATE","PLATFORM","PLAYER","PLEASE","PLEASURE","PLENTY","POCKET","POETRY","POINT","POISON","POLICE","POLICY","POLITICAL","POLITICS","POLLUTION","POOL","POPULAR","POPULATION","PORTION","PORTRAIT","POSITION","POSITIVE","POSSESS","POSSIBLE","POSTPONE","POTATO","POTENTIAL","POVERTY","POWER","POWERFUL","PRACTICAL","PRACTICE","PRAYER","PRECISE","PREDICT","PREFER","PREGNANCY","PREPARE","PRESENCE","PRESENT","PRESERVE","PRESIDENT","PRESS","PRESSURE","PRETEND","PRETTY","PREVENT","PREVIOUS","PRICE","PRIDE","PRIMARY","PRINCIPLE","PRINT","PRIOR","PRIORITY","PRISON","PRISONER","PRIVATE","PROBABLY","PROBLEM","PROCEDURE","PROCESS","PRODUCE","PRODUCT","PRODUCTION","PROFESSION","PROFESSOR","PROFILE","PROFIT","PROGRAM","PROGRESS","PROJECT","PROMISE","PROMOTE","PROMPT","PROOF","PROPER","PROPERLY","PROPERTY","PROPOSAL","PROPOSE","PROSPECT","PROTECT","PROTECTION","PROTEIN","PROTEST","PROVIDE","PROVIDER","PROVINCE","PUBLIC","PUBLICATION","PUBLISH","PULLING","PUNISH","PURCHASE","PURPOSE","PUSHING","PUZZLE","QUALITY","QUANTITY","QUARTER","QUARTET","QUESTION","QUICKLY","QUIET","QUIETLY","QUITTING","RACING","RADICAL","RADIO","RAILROAD","RAISING","RANDOM","RANGE","RAPIDLY","RATING","REACH","REACTION","READER","READILY","READING","REALITY","REALIZE","REALLY","REASON","REASONABLE","RECALL","RECEIVE","RECENT","RECENTLY","RECEPTION","RECIPE","RECOGNIZE","RECOMMEND","RECORD","RECORDING","RECOVER","RECOVERY","RECRUIT","REDUCE","REDUCTION","REFER","REFERENCE","REFLECT","REFORM","REFUSE","REGARD","REGIME","REGION","REGIONAL","REGISTER","REGRET","REGULAR","REGULATE","REINFORCE","REJECT","RELATE","RELATED","RELATION","RELATIONSHIP","RELATIVE","RELAX","RELEASE","RELEVANT","RELIEF","RELIGION","RELIGIOUS","RELY","REMAIN","REMARKABLE","REMEMBER","REMIND","REMOTE","REMOVE","REPEAT","REPEATEDLY","REPLACE","REPLY","REPORT","REPORTER","REPRESENT","REPUBLIC","REPUTATION","REQUEST","REQUIRE","REQUIREMENT","RESCUE","RESEARCH","RESEMBLE","RESERVE","RESIDENT","RESIST","RESISTANCE","RESOLVE","RESORT","RESOURCE","RESPECT","RESPOND","RESPONSE","RESPONSIBLE","RESTAURANT","RESTORE","RESULT","RETAIN","RETIRE","RETURN","REVEAL","REVENUE","REVIEW","REVOLUTION","RHYTHM","RIDING","RIGHT","RINGING","ROBOT","ROCKET","ROMANCE","ROOF","ROUTINE","ROYAL","RULING","RUNNING","RURAL","SACRED","SACRIFICE","SAFETY","SALARY","SAMPLE","SANDWICH","SATELLITE","SATISFY","SAVING","SAYING","SCALE","SCANDAL","SCARED","SCATTER","SCENARIO","SCENE","SCHEDULE","SCHEME","SCHOLAR","SCHOOL","SCIENCE","SCIENTIFIC","SCIENTIST","SCORE","SCREEN","SCRIPT","SCULPTURE","SEARCH","SEASON","SECOND","SECRET","SECRETARY","SECTION","SECTOR","SECURE","SECURITY","SEEKER","SEEMED","SELECT","SELECTION","SENATE","SENATOR","SENIOR","SENSE","SENSITIVE","SENTENCE","SEPARATE","SEQUENCE","SERIES","SERIOUS","SERIOUSLY","SERVANT","SERVE","SERVICE","SESSION","SETTING","SETTLE","SEVENTH","SEVERAL","SEVERE","SHADOW","SHAKE","SHALL","SHALLOW","SHAME","SHAPE","SHARE","SHARP","SHEET","SHELF","SHELTER","SHIFT","SHINE","SHINING","SHIRT","SHOCK","SHOOT","SHOOTING","SHORT","SHORTLY","SHOULDER","SHOUT","SHOWER","SHRUG","SHUTTER","SICKNESS","SIDEWALK","SIGHT","SIGNAL","SIGNATURE","SIGNIFICANCE","SILENCE","SILENT","SILVER","SIMILAR","SIMPLE","SIMPLY","SINCERE","SINGER","SINGLE","SISTER","SITTING","SITUATION","SKETCH","SKILL","SKINNY","SLAVERY","SLEEP","SLEEVE","SLICE","SLIGHT","SLIPPING","SLOWLY","SMALL","SMART","SMELL","SMILE","SMILING","SMOKING","SMOOTH","SNAKE","SOCCER","SOCIAL","SOCIETY","SOFTLY","SOFTWARE","SOLAR","SOLDIER","SOLID","SOLUTION","SOLVE","SOMEBODY","SOMEHOW","SOMEONE","SOMETHING","SOMETIME","SOMEWHAT","SOMEWHERE","SORRY","SOUND","SOURCE","SOUTH","SOUTHERN","SPACE","SPEAK","SPEAKER","SPECIAL","SPECIALIST","SPECIES","SPECIFIC","SPEECH","SPEED","SPELL","SPEND","SPHERE","SPICE","SPIDER","SPIRIT","SPIRITUAL","SPITE","SPLIT","SPOKEN","SPONSOR","SPORT","SPOTLIGHT","SPREAD","SPRING","SQUARE","SQUEEZE","STABILITY","STABLE","STAFF","STAGE","STAIRS","STAKE","STAND","STANDARD","STANDING","START","STATE","STATEMENT","STATION","STATUS","STAYING","STEADY","STEAL","STEEL","STICK","STIFF","STILL","STOMACH","STONE","STORAGE","STORE","STORM","STORY","STRAIGHT","STRANGE","STRANGER","STRATEGY","STREAM","STREET","STRENGTH","STRESS","STRETCH","STRICT","STRIKE","STRING","STRIP","STROKE","STRONG","STRUCTURE","STRUGGLE","STUDENT","STUDIO","STUDY","STUFF","STUPID","STYLE","SUBJECT","SUBMIT","SUBSTANCE","SUBTLE","SUBURB","SUCCEED","SUCCESS","SUDDEN","SUDDENLY","SUFFER","SUGGEST","SUGGESTION","SUICIDE","SUITABLE","SUMMER","SUNDAY","SUNLIGHT","SUNRISE","SUNSET","SUPER","SUPPLY","SUPPORT","SUPPORTER","SUPPOSE","SUPPOSED","SUPREME","SURFACE","SURGERY","SURPRISE","SURROUND","SURVEY","SURVIVE","SUSPECT","SUSTAIN","SWEATER","SWIMMING","SWITCH","SYMBOL","SYMPATHY","SYMPTOM","SYSTEM","TABLE","TACKLE","TALENT","TALKING","TARGET","TASTE","TAXES","TEACHER","TEACHING","TEAMMATE","TECHNICAL","TECHNIQUE","TECHNOLOGY","TEENAGE","TEENAGER","TELEPHONE","TELESCOPE","TELEVISION","TELLING","TEMPERATURE","TEMPLE","TEMPORARY","TENDENCY","TENNIS","TENSION","TERRIBLE","TERRITORY","TERROR","TESTIFY","TESTIMONY","TESTING","TEXTBOOK","TEXTURE","THANK","THANKS","THEATRE","THEFT","THEIR","THEME","THEMSELVES","THEN","THEORY","THERAPY","THERE","THEREFORE","THESE","THICK","THING","THINK","THINKING","THIRD","THIRTY","THOSE","THOUGH","THOUGHT","THOUSAND","THREAT","THREATEN","THREE","THROAT","THROUGH","THROUGHOUT","THROW","THUMB","TICKET","TIGHT","TIMING","TINY","TIRED","TISSUE","TITLE","TOBACCO","TODAY","TOILET","TOMATO","TOMORROW","TONGUE","TONIGHT","TOO","TOPIC","TOTAL","TOTALLY","TOUCH","TOUGH","TOURING","TOURISM","TOURIST","TOWARD","TOWARDS","TOWER","TOXIC","TRACE","TRACK","TRADE","TRADITION","TRAFFIC","TRAGEDY","TRAIL","TRAIN","TRAINING","TRANSFER","TRANSFORM","TRANSLATE","TRANSPORT","TRAVEL","TREAT","TREATMENT","TREATY","TREND","TRIAL","TRIANGLE","TRIBAL","TRICK","TROOP","TROPHY","TROUBLE","TRUCK","TRULY","TRUMPET","TRUNK","TRUST","TRUTH","TRYING","TUNNEL","TURNING","TWENTY","TWICE","TWIST","TYPICAL","UGLY","UNABLE","UNCERTAIN","UNCLE","UNCOVER","UNDER","UNDERGO","UNDERSTAND","UNFORTUNATELY","UNIFORM","UNION","UNIQUE","UNITE","UNITED","UNITY","UNIVERSE","UNIVERSITY","UNKNOWN","UNLESS","UNLIKE","UNLIKELY","UNTIL","UNUSUAL","UPGRADE","UPPER","UPSET","URBAN","URGENT","USAGE","USEFUL","USELESS","USER","USUAL","USUALLY","UTILITY","VACATION","VALLEY","VALUABLE","VALUE","VARIETY","VARIOUS","VASTLY","VEGETABLE","VEHICLE","VENTURE","VERSION","VERTICAL","VERY","VESSEL","VETERAN","VICTIM","VICTORY","VIDEO","VIEWER","VILLAGE","VIOLENCE","VIOLENT","VIRTUAL","VIRTUE","VIRUS","VISIBLE","VISION","VISIT","VISITOR","VISUAL","VITAL","VOICE","VOLUME","VOLUNTEER","VOTING","WAITING","WAKING","WALKING","WALLET","WANDER","WARNING","WARRANT","WARRIOR","WASTE","WATCH","WATCHING","WATER","WEAKNESS","WEALTH","WEALTHY","WEAPON","WEATHER","WEBSITE","WEDDING","WEEKEND","WEEKLY","WEIGH","WEIGHT","WELCOME","WELFARE","WESTERN","WHEAT","WHEEL","WHEN","WHENEVER","WHERE","WHEREAS","WHETHER","WHICH","WHILE","WHISPER","WHITE","WHOLE","WHOSE","WIDELY","WIDOW","WIDTH","WILDLIFE","WILLING","WINDOW","WINNER","WINTER","WISDOM","WISHING","WITHDRAW","WITHIN","WITHOUT","WITNESS","WOMAN","WONDER","WONDERFUL","WOODEN","WORKER","WORKING","WORKOUT","WORKS","WORKSHOP","WORLD","WORRIED","WORRY","WORSE","WORTH","WOULD","WOUND","WOUNDED","WRAPPED","WRITER","WRITING","WRITTEN","WRONG"]; // Removed YOURSELF, YOUTH, WNORMAL, WRITTTEN etc.
        const TAGLINES = ["'I am' is the shortest complete sentence.","The dot over the 'i' is called a tittle.","'Bookkeeper' has three consecutive double letters.","A new word is added to the dictionary every two hours.","The most common letter is 'E'.","The least common letter is 'Z'.","'Stewardesses' is the longest word typed with only the left hand.","'Dreamt' is the only word that ends in 'mt'.","A pangram contains every letter of the alphabet.","'Almost' is the longest word with letters in alphabetical order.","The oldest English word is 'town'.","'Queue' sounds the same even if you remove the last four letters.","'Four' is the only number whose letters are in alphabetical order.","'One' is the only one in reverse alphabetical order.","A word with no vowels is a 'glyph'.","'Uncopyrightable' is a long word with no repeating letters.","A 'contronym' is a word with two opposite meanings (e.g. 'cleave').","'Underground' begins and ends with 'und'.","The longest one-syllable word is 'screeched'.","'Rhythm' is the longest word without a, e, i, o, or u.","A 'palindrome' reads the same forwards and backwards.","Shakespeare invented over 1,700 words.","'Goddessship' is the only word with a triple letter.","The 'Q' in 'QWERTY' is almost always followed by a 'U'.","'Abstemious' contains all five vowels in order.","A 'portmanteau' blends two words (e.g. 'smog').","'Subbookkeeper' has four pairs of double letters.","The longest word in English has 45 letters.","What seven-letter word has three 'U's? 'Triumphs'?","No, the seven-letter word with three 'U's is 'unusual'.","A 'ghost word' is a word that appeared in a dictionary by error.","'Therein' contains seven words without rearranging letters.","'Indivisibility' has only one vowel, repeated six times.","The word 'set' has the most definitions.","'Go' is the shortest complete sentence.","There are words that only exist in plural form, like 'scissors'.","'Listen' and 'silent' use the same letters.","The sixth sick sheik's sixth sheep's sick.","The past tense of 'yeet' is 'yote'. Maybe.","To 'plenish' is the opposite of 'replenish'.","A 'jiffy' is an actual unit of time (1/100th of a second).","'Month', 'orange', 'silver', 'purple'... do not rhyme.","'Spoonfeed' is the longest word with letters in reverse alphabetical order.","The shortest '-ology' (study of) is 'oology' (study of eggs).","'Iouea' is a sea sponge and has all 5 vowels.","A 'Trellis' is a framework for supporting plants.","We think 'Trellis' is a better name than 'WordGrid'.","What's another word for 'Thesaurus'?","A 'crwth' is a Welsh instrument without vowels.","'Book' and 'read' are four-letter words."];
        let PUZZLE;
        let startTime, moveCount, firstTryBonus, firstCheckUsed;
        const CHECKS_AVAILABLE = 6;

        function simplePRNG(seed) { let a = seed; return function() { a ^= a << 13; a ^= a >> 17; a ^= a << 5; return (a & 0x7FFFFFFF) / 0x80000000; }; }
        
        // --- UPDATED: Get today's date as a "scrambled" seed number ---
        function getDailySeed() {
            const now = new Date();
            const day = now.getDate(); // 1-31
            const month = now.getMonth() + 1; // 1-12
            const year = now.getFullYear();
            
            // Simple string hash function (sdbm) to scramble the date string (e.g., "2025-10-30")
            // This ensures consecutive dates produce wildly different seeds
            const str = `${year}-${month}-${day}`;
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = char + (hash << 6) + (hash << 16) - hash;
            }
            // Ensure positive integer
            let positiveHash = hash & 0x7FFFFFFF;
            console.log(`Today's Date: ${str}, Seed: ${positiveHash}`); // Log the seed
            return positiveHash;
        }

        function generatePuzzle(randomFunc) {
            let isValidPuzzle = false;
            let generatedPuzzle;
            let attempts = 0;
            const stemLength = 7;
            const maxAttempts = 10000; // Increased from 5000

            while (!isValidPuzzle && attempts < maxAttempts) {
                attempts++;
                const stemIndex = Math.floor(randomFunc() * STEM_WORDS.length);
                const stem = STEM_WORDS[stemIndex];
                
                if (!stem || stem.length !== stemLength) { 
                    // This check is crucial after cleaning the list
                    console.warn(`Attempt ${attempts}: Invalid stem selected (index ${stemIndex}, value ${stem}, length ${stem?.length}). Retrying.`); 
                    continue; 
                }

                const solution = [];
                let possible = true;
                let usedPatterns = {};
                let usedWords = new Set(); // --- BUG FIX: Track used words per attempt ---

                for (const stemLetter of stem) {
                    let possibleWords = ALL_WORDS.filter(word => word && word.length === 4 && word.includes(stemLetter));
                    if (possibleWords.length === 0) { 
                        // console.warn(`Attempt ${attempts}: No 4-letter words found for stem letter '${stemLetter}' in stem '${stem}'.`);
                        possible = false; 
                        break; 
                    }
                    if (usedPatterns[stemLetter]) { 
                        possibleWords = possibleWords.filter(word => word && !usedPatterns[stemLetter].includes(word.indexOf(stemLetter))); 
                    }
                    if (possibleWords.length === 0) { 
                        // console.warn(`Attempt ${attempts}: No 4-letter words left for '${stemLetter}' after checking used patterns.`);
                        possible = false; 
                        break; 
                    }
                    
                    // --- BUG FIX: Filter out already used words ---
                    possibleWords = possibleWords.filter(word => !usedWords.has(word));
                    if (possibleWords.length === 0) { 
                        // console.warn(`Attempt ${attempts}: No 4-letter words left for '${stemLetter}' after checking *usedWords*.`);
                        possible = false; 
                        break; 
                    }
                    // --- END BUG FIX ---


                    const wordIndex = Math.floor(randomFunc() * possibleWords.length);
                    const word = possibleWords[wordIndex];
                     if (!word) { 
                        // console.warn(`Attempt ${attempts}: Failed to select word for ${stemLetter}`); 
                        possible = false; 
                        break; 
                    }
                    const stemIdxInWord = word.indexOf(stemLetter);
                     if (stemIdxInWord === -1) { 
                        // console.warn(`Attempt ${attempts}: Letter ${stemLetter} not found in ${word}.`); 
                        possible = false; 
                        break; 
                    }

                    if (!usedPatterns[stemLetter]) usedPatterns[stemLetter] = [];
                    usedPatterns[stemLetter].push(stemIdxInWord);
                    
                    usedWords.add(word); // --- BUG FIX: Add chosen word to set ---
                    solution.push({ word, stemIndex: stemIdxInWord });
                }
                if (!possible) continue;

                let requiredTrayLetters = [];
                 solution.forEach(sol => { 
                    if (sol.word) { 
                        for(let i = 0; i < sol.word.length; i++) { 
                            if (i !== sol.stemIndex) requiredTrayLetters.push(sol.word[i]); 
                        } 
                    } else { 
                        // console.warn(`Attempt ${attempts}: Solution missing word.`); 
                        possible = false; 
                    } 
                });
                 if (!possible) continue;

                let requiredCounts = {}; requiredTrayLetters.forEach(l => requiredCounts[l] = (requiredCounts[l] || 0) + 1);
                let actualTrayLetters = requiredTrayLetters.join(''); let actualTrayCounts = {}; actualTrayLetters.split('').forEach(l => actualTrayCounts[l] = (actualTrayCounts[l] || 0) + 1);
                let countsMatch = true; for (const letter in requiredCounts) { if (!actualTrayCounts[letter] || actualTrayCounts[letter] !== requiredCounts[letter]) { countsMatch = false; break; } } if (countsMatch) { for (const letter in actualTrayCounts) { if (!requiredCounts[letter]) { countsMatch = false; break; } } }

                if (countsMatch && actualTrayLetters.length === stemLength * 3) {
                    isValidPuzzle = true;
                    generatedPuzzle = { stem, solution, trayLetters: actualTrayLetters };
                    console.log(`Generated Puzzle (Stem: ${stem}) after ${attempts} attempts:`, generatedPuzzle);
                } else if (attempts % 500 === 0) { 
                    // console.warn(`Attempt ${attempts}: Economy/length check failed (${actualTrayLetters.length}). Stem: ${stem}. Match: ${countsMatch}`); 
                }
            } // End while loop

            if (!isValidPuzzle) {
                 console.error(`CRITICAL FAILURE: Could not generate valid puzzle after ${maxAttempts} attempts.`);
                 // Fallback remains the same
                 return { stem: "CABINET", solution: [{ word: "BACK", stemIndex: 2 }, { word: "ABLE", stemIndex: 1 }, { word: "BILL", stemIndex: 0 }, { word: "TINY", stemIndex: 2 }, { word: "NAME", stemIndex: 2 }, { word: "EACH", stemIndex: 0 }, { word: "CHAT", stemIndex: 3 }], trayLetters: "BAKBLELILTYINAMEACHHAT" };
            }
            return generatedPuzzle;
        }


        const elements = {
            grid: document.getElementById('puzzle-grid'),
            tray: document.getElementById('letter-tray'),
            checkBtn: document.getElementById('check-btn'),
            lights: document.getElementById('check-lights'),
            message: document.getElementById('message-area'),
            endGameModal: document.getElementById('end-game-stats-modal'),
            endGameModalOverlay: document.getElementById('end-game-stats-modal-overlay'),
            practiceBtn: document.getElementById('practice-btn'),
            shareBtn: document.getElementById('share-btn'),
            solutionDisplay: document.getElementById('solution-display'),
            solutionTextEl: document.getElementById('solution-text'),
            modalTitle: document.getElementById('modal-title'),
            finalTimeEl: document.getElementById('final-time'),
            finalMovesEl: document.getElementById('final-moves'),
            moveBonusEl: document.getElementById('move-bonus'),
            firstTryBonusEl: document.getElementById('first-try-bonus'),
            checkBonusEl: document.getElementById('check-bonus'),
            finalScoreEl: document.getElementById('final-score'),
            persistentStatsBtn: document.getElementById('persistent-stats-btn'),
            persistentStatsModal: document.getElementById('persistent-stats-modal'),
            persistentStatsModalOverlay: document.getElementById('persistent-stats-modal-overlay'),
            closePersistentStatsBtn: document.getElementById('close-persistent-stats-btn'),
            statsPlayedEl: document.getElementById('stats-played'),
            statsWinPctEl: document.getElementById('stats-win-pct'),
            statsStreakEl: document.getElementById('stats-streak'),
            statsMaxStreakEl: document.getElementById('stats-max-streak'),
            startScreen: document.getElementById('start-screen'),
            playBtn: document.getElementById('play-btn'),
            helpBtn: document.getElementById('help-btn'),
            settingsBtn: document.getElementById('settings-btn'),
            helpModalOverlay: document.getElementById('help-modal-overlay'),
            settingsModalOverlay: document.getElementById('settings-modal-overlay'),
            closeHelpBtn: document.getElementById('close-help-btn'),
            closeSettingsBtn: document.getElementById('close-settings-btn'),
            closeEndGameStatsBtn: document.getElementById('close-end-game-stats-btn'),
            themeToggle: document.getElementById('theme-toggle'),
            contrastToggle: document.getElementById('contrast-toggle'), // --- NEW ---
            tagline: document.getElementById('tagline'),
            moveCountText: document.getElementById('move-count-text'),
            resetDailyBtn: document.getElementById('reset-daily-btn')
        };

        // --- UPDATED: Added settings key ---
        const LS_KEYS = { 
            DAILY_STATE: 'trellisDailyState', 
            DAILY_STATS: 'trellisDailyStats',
            SETTINGS: 'trellisSettings' // --- NEW ---
        };
        
        // --- NEW: Settings object ---
        let settings = {
            darkMode: true,
            highContrast: false
        };

        let persistentStats = { gamesPlayed: 0, wins: 0, currentStreak: 0, maxStreak: 0, lastPlayedDateSeed: null };
        let currentDailyState = null;
        let state = { selectedLetter: null, checksRemaining: CHECKS_AVAILABLE, lockedRows: new Set(), startTime: Date.now(), moveCount: 0, firstTryBonus: 0, firstCheckUsed: false };

        // --- NEW: Load/Save Settings ---
        function loadSettings() {
             try {
                const s = localStorage.getItem(LS_KEYS.SETTINGS);
                if (s) {
                    settings = JSON.parse(s);
                    console.log("Loaded settings:", settings);
                } else {
                     console.log("No settings found, using defaults.");
                     // Check OS preference for dark mode
                     settings.darkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                }
             } catch (e) {
                 console.error("Load Settings Fail:", e);
                 settings = { darkMode: true, highContrast: false }; // Fallback
             }
        }
        function saveSettings() {
             try {
                localStorage.setItem(LS_KEYS.SETTINGS, JSON.stringify(settings));
                console.log("Settings saved.");
             } catch (e) {
                 console.error("Save Settings Fail:", e);
             }
        }
        
        // --- NEW: Apply Settings to UI ---
        function applySettings() {
             // Apply Dark Mode
             document.body.classList.toggle('light-mode', !settings.darkMode);
             elements.themeToggle.checked = settings.darkMode;
             
             // Apply High Contrast Mode
             document.body.classList.toggle('high-contrast', settings.highContrast);
             elements.contrastToggle.checked = settings.highContrast;
        }


        function loadPersistentStats() { try { const s = localStorage.getItem(LS_KEYS.DAILY_STATS); if (s) persistentStats = JSON.parse(s); } catch (e) { console.error("Load Stats Fail:", e); persistentStats = { gamesPlayed: 0, wins: 0, currentStreak: 0, maxStreak: 0, lastPlayedDateSeed: null }; } }
        function savePersistentStats() { try { localStorage.setItem(LS_KEYS.DAILY_STATS, JSON.stringify(persistentStats)); } catch (e) { console.error("Save Stats Fail:", e); } }
        function updatePersistentStats(isWin) { const todaySeed = getDailySeed(); if (persistentStats.lastPlayedDateSeed !== todaySeed) { persistentStats.gamesPlayed++; if (isWin) { persistentStats.wins++; const y = new Date(); y.setDate(y.getDate() - 1); const ySeed = (y.getFullYear() * 10000) + (y.getMonth() * 100) + y.getDate(); if (persistentStats.lastPlayedDateSeed === ySeed) persistentStats.currentStreak++; else persistentStats.currentStreak = 1; persistentStats.maxStreak = Math.max(persistentStats.maxStreak, persistentStats.currentStreak); } else { persistentStats.currentStreak = 0; } persistentStats.lastPlayedDateSeed = todaySeed; savePersistentStats(); } }
        function displayPersistentStats() { elements.statsPlayedEl.textContent = persistentStats.gamesPlayed; const wp = persistentStats.gamesPlayed > 0 ? Math.round((persistentStats.wins / persistentStats.gamesPlayed) * 100) : 0; elements.statsWinPctEl.textContent = wp; elements.statsStreakEl.textContent = persistentStats.currentStreak; elements.statsMaxStreakEl.textContent = persistentStats.maxStreak; }

        function initGame(isPracticeGame = false) {
            let seed;
            let randomFunc = Math.random;
            let dayOfMonth = (new Date()).getDate(); // --- BUG FIX ---

            try {
                let savedState = null;
                if (isPracticeGame) {
                    console.log("Starting Practice Game...");
                    PUZZLE = generatePuzzle(randomFunc);
                    if (!PUZZLE) throw new Error("Practice Puzzle generation failed."); // Check after generation
                    currentDailyState = null;
                    elements.playBtn.textContent = "Play Daily";
                } else {
                    console.log("Starting Daily Game...");
                    seed = getDailySeed();
                    randomFunc = simplePRNG(seed);
                    
                    // --- BUG FIX: "Warm up" the RNG to avoid daily collisions ---
                    // Run the generator a number of times based on the day of the month
                    // This ensures consecutive seeds (like ...577 and ...578) start from a different point
                    let warmups = (dayOfMonth % 10) + 5; // Run 5-14 times
                    console.log(`Warming up RNG ${warmups} times...`);
                    for (let i = 0; i < warmups; i++) {
                        randomFunc(); // Discard the result
                    }
                    // --- END BUG FIX ---

                    PUZZLE = generatePuzzle(randomFunc);
                    if (!PUZZLE) throw new Error("Daily Puzzle generation failed."); // Check after generation

                    savedState = loadDailyState(seed);
                    if (savedState) {
                        console.log("Loaded saved state:", savedState);
                        currentDailyState = savedState;
                        // Ensure shareGridHistory is an array on load
                        if (!Array.isArray(currentDailyState.shareGridHistory)) currentDailyState.shareGridHistory = [];
                    } else {
                        console.log("No saved state found for today.");
                        currentDailyState = { seed: seed, board: null, lockedRows: [], checksRemaining: CHECKS_AVAILABLE, moveCount: 0, startTime: Date.now(), firstCheckUsed: false, isComplete: false, statsRecorded: false, shareGridHistory: [] };
                    }
                    elements.playBtn.textContent = "Practice";
                }

            } catch (error) {
                 console.error("Init Error:", error);
                 elements.message.textContent = "Load Error. Please refresh."; // Simple user message
                 elements.checkBtn.disabled = true;
                 elements.playBtn.disabled = true;
                 return; // Stop execution
            }

            state = { selectedLetter: null, checksRemaining: currentDailyState ? currentDailyState.checksRemaining : CHECKS_AVAILABLE, lockedRows: currentDailyState ? new Set(currentDailyState.lockedRows) : new Set(), startTime: currentDailyState ? currentDailyState.startTime : Date.now(), moveCount: currentDailyState ? currentDailyState.moveCount : 0, firstTryBonus: 0, firstCheckUsed: currentDailyState ? currentDailyState.firstCheckUsed : false };
            elements.grid.innerHTML = ''; elements.tray.innerHTML = ''; elements.message.textContent = ''; elements.endGameModalOverlay.classList.remove('visible'); elements.solutionDisplay.style.display = 'none';
            elements.lights.innerHTML = ''; for (let i = 0; i < CHECKS_AVAILABLE; i++) { const light = document.createElement('div'); light.classList.add('check-light'); if (i < (CHECKS_AVAILABLE - state.checksRemaining)) light.classList.add('used'); elements.lights.appendChild(light); }

             PUZZLE.solution.forEach((sol, i) => { const row = document.createElement('div'); row.classList.add('grid-row'); row.style.gridTemplateColumns = `repeat(7, var(--tile-size))`; for (let j = 0; j < 7; j++) { const tile = document.createElement('div'); if (j === 3) { tile.classList.add('grid-tile', 'stem-letter'); tile.dataset.row = i; const letter = document.createElement('div'); letter.classList.add('letter-tile'); if (state.lockedRows.has(i)) letter.classList.add('locked'); letter.textContent = PUZZLE.stem[i]; tile.appendChild(letter); } else { let isEmptySlot = false; if (sol.stemIndex === 0 && (j === 4 || j === 5 || j === 6)) isEmptySlot = true; else if (sol.stemIndex === 1 && (j === 2 || j === 4 || j === 5)) isEmptySlot = true; else if (sol.stemIndex === 2 && (j === 1 || j === 2 || j === 4)) isEmptySlot = true; else if (sol.stemIndex === 3 && (j === 0 || j === 1 || j === 2)) isEmptySlot = true; if (isEmptySlot) { tile.classList.add('grid-tile', 'empty'); tile.dataset.row = i; tile.dataset.col = j; } else tile.classList.add('placeholder-tile'); } row.appendChild(tile); } elements.grid.appendChild(row); });
            elements.tray.innerHTML = ''; const trayRows = [document.createElement('div'), document.createElement('div'), document.createElement('div')]; trayRows.forEach((row) => { row.classList.add('tray-row'); row.style.gridTemplateColumns = `repeat(7, var(--tile-size))`; elements.tray.appendChild(row); }); const trayTiles = []; for(let i=0; i < 21; i++) { const trayTile = document.createElement('div'); trayTile.classList.add('tray-tile'); trayTile.dataset.trayIndex = i; trayTile.addEventListener('click', handleTileClick); trayTiles.push(trayTile); }

            const trayLetters = PUZZLE.trayLetters.split('');
            const initialBoardState = currentDailyState?.board || null;
            if (initialBoardState) {
                const placedLettersMap = new Map(); initialBoardState.forEach(item => { if (item.letter) { placedLettersMap.set(item.letter, (placedLettersMap.get(item.letter) || 0) + 1); const letterTile = document.createElement('div'); letterTile.classList.add('letter-tile'); letterTile.textContent = item.letter; letterTile.addEventListener('click', handleTileClick); let targetTile = null; if (item.location === 'grid') targetTile = document.querySelector(`.grid-tile.empty[data-row='${item.row}'][data-col='${item.col}']`); else if (item.location === 'tray') targetTile = document.querySelector(`.tray-tile[data-tray-index='${item.index}']`); if (targetTile) { if (targetTile.children.length === 0) targetTile.appendChild(letterTile); else console.warn("Occupied slot:", item); } else console.warn("Target tile not found:", item); } }); const originalTrayCounts = {}; trayLetters.forEach(l => originalTrayCounts[l] = (originalTrayCounts[l] || 0) + 1); placedLettersMap.forEach((count, letter) => { if (originalTrayCounts[letter]) originalTrayCounts[letter] -= count; }); const remainingTrayLetters = []; for (const letter in originalTrayCounts) { for (let k = 0; k < originalTrayCounts[letter]; k++) remainingTrayLetters.push(letter); }
                remainingTrayLetters.sort(() => randomFunc() - 0.5); let remainingIdx = 0; trayTiles.forEach(tile => { if (tile.children.length === 0 && remainingIdx < remainingTrayLetters.length) { const letterTile = document.createElement('div'); letterTile.classList.add('letter-tile'); letterTile.textContent = remainingTrayLetters[remainingIdx]; letterTile.addEventListener('click', handleTileClick); tile.appendChild(letterTile); remainingIdx++; } });
                if (!currentDailyState.isComplete) handleCheck(true);
            } else {
                trayLetters.sort(() => randomFunc() - 0.5).forEach((char, i) => { if (trayTiles[i] && trayTiles[i].children.length === 0) { const letterTile = document.createElement('div'); letterTile.classList.add('letter-tile'); letterTile.textContent = char; letterTile.addEventListener('click', handleTileClick); trayTiles[i].appendChild(letterTile); } });
            }

             trayTiles.slice(0, 7).forEach(tile => trayRows[0].appendChild(tile)); trayTiles.slice(7, 14).forEach(tile => trayRows[1].appendChild(tile)); trayTiles.slice(14, 21).forEach(tile => trayRows[2].appendChild(tile));
            attachTileListeners(); elements.checkBtn.disabled = (currentDailyState && currentDailyState.isComplete); updateMoveCounter(); if (currentDailyState && currentDailyState.isComplete) endGame(true, true);
        }


        function attachTileListeners() { document.querySelectorAll('.grid-tile.empty').forEach(t => { t.removeEventListener('click', handleTileClick); t.addEventListener('click', handleTileClick); }); elements.tray.querySelectorAll('.letter-tile').forEach(t => { t.removeEventListener('click', handleTileClick); t.addEventListener('click', handleTileClick); }); elements.tray.querySelectorAll('.tray-tile').forEach(t => { if (t.children.length === 0) { t.removeEventListener('click', handleTileClick); t.addEventListener('click', handleTileClick); } }); }
        function startGame() { elements.tagline.textContent = TAGLINES[Math.floor(Math.random() * TAGLINES.length)]; elements.startScreen.style.opacity = '0'; elements.startScreen.style.visibility = 'hidden'; const seed = getDailySeed(); const savedState = loadDailyState(seed); if (savedState && !savedState.isComplete) initGame(false); else initGame(false); }
        function updateMoveCounter() { if (elements.moveCountText) elements.moveCountText.textContent = state.moveCount; }
        function handleTileClick(e) { e.stopPropagation(); const clickedElement = e.currentTarget; if (currentDailyState && currentDailyState.isComplete) return; if (clickedElement.classList.contains('letter-tile')) { const letterTile = clickedElement; if (letterTile.classList.contains('locked')) return; if (state.selectedLetter === letterTile) { state.selectedLetter.classList.remove('selected'); state.selectedLetter = null; } else if (state.selectedLetter) { const sourceContainer = state.selectedLetter.parentElement; const targetContainer = letterTile.parentElement; if (targetContainer.classList.contains('stem-letter')) return; targetContainer.appendChild(state.selectedLetter); sourceContainer.appendChild(letterTile); state.moveCount++; updateMoveCounter(); state.selectedLetter.classList.remove('hint-correct', 'hint-present', 'hint-incorrect'); letterTile.classList.remove('hint-correct', 'hint-present', 'hint-incorrect'); state.selectedLetter.classList.remove('selected'); state.selectedLetter = null; saveDailyState(); } else { state.selectedLetter = letterTile; state.selectedLetter.classList.add('selected'); } } else if (clickedElement.classList.contains('empty')) { const gridTileContainer = clickedElement; if (state.selectedLetter && gridTileContainer.children.length === 0) { gridTileContainer.appendChild(state.selectedLetter); state.selectedLetter.classList.remove('hint-correct', 'hint-present', 'hint-incorrect'); state.selectedLetter.classList.remove('selected'); state.selectedLetter = null; state.moveCount++; updateMoveCounter(); saveDailyState(); } } else if (clickedElement.classList.contains('tray-tile') && clickedElement.children.length === 0) { if (state.selectedLetter) { const sourceContainer = state.selectedLetter.parentElement; if(sourceContainer.classList.contains('grid-tile')) { clickedElement.appendChild(state.selectedLetter); state.selectedLetter.classList.remove('hint-correct', 'hint-present', 'hint-incorrect'); state.selectedLetter.classList.remove('selected'); state.selectedLetter = null; state.moveCount++; updateMoveCounter(); saveDailyState(); } } } }

        elements.playBtn.addEventListener('click', () => { if (elements.playBtn.textContent.includes("Daily")) startGame(); else initGame(true); });
        elements.checkBtn.addEventListener('click', () => handleCheck(false));
        elements.practiceBtn.addEventListener('click', () => { initGame(true); elements.endGameModalOverlay.classList.remove('visible'); });
        elements.shareBtn.addEventListener('click', handleShare);
        elements.helpBtn.addEventListener('click', () => elements.helpModalOverlay.classList.add('visible'));
        elements.closeHelpBtn.addEventListener('click', () => elements.helpModalOverlay.classList.remove('visible'));
        elements.helpModalOverlay.addEventListener('click', (e) => { if (e.target === elements.helpModalOverlay) elements.helpModalOverlay.classList.remove('visible'); });
        elements.settingsBtn.addEventListener('click', () => elements.settingsModalOverlay.classList.add('visible'));
        elements.closeSettingsBtn.addEventListener('click', () => elements.settingsModalOverlay.classList.remove('visible'));
        elements.settingsModalOverlay.addEventListener('click', (e) => { if (e.target === elements.settingsModalOverlay) elements.settingsModalOverlay.classList.remove('visible'); });
        elements.closeEndGameStatsBtn.addEventListener('click', () => elements.endGameModalOverlay.classList.remove('visible'));
        elements.endGameModalOverlay.addEventListener('click', (e) => { if (e.target === elements.endGameModalOverlay) elements.endGameModalOverlay.classList.remove('visible'); });
        elements.persistentStatsBtn.addEventListener('click', () => { displayPersistentStats(); elements.persistentStatsModalOverlay.classList.add('visible'); });
        elements.closePersistentStatsBtn.addEventListener('click', () => elements.persistentStatsModalOverlay.classList.remove('visible'));
        elements.persistentStatsModalOverlay.addEventListener('click', (e) => { if (e.target === elements.persistentStatsModalOverlay) elements.persistentStatsModalOverlay.classList.remove('visible'); });
        
        // --- UPDATED: Theme Toggle Listener ---
        elements.themeToggle.addEventListener('change', () => { 
            settings.darkMode = elements.themeToggle.checked;
            document.body.classList.toggle('light-mode', !settings.darkMode);
            saveSettings();
        });
        
        // --- NEW: Contrast Toggle Listener ---
        elements.contrastToggle.addEventListener('change', () => {
            settings.highContrast = elements.contrastToggle.checked;
            document.body.classList.toggle('high-contrast', settings.highContrast);
            saveSettings();
        });
        
        elements.resetDailyBtn.addEventListener('click', () => { 
            // Using a simple log instead of confirm()
            console.log("Resetting daily progress...");
            if (currentDailyState) { 
                clearDailyState(currentDailyState.seed); 
                initGame(false); 
                elements.settingsModalOverlay.classList.remove('visible'); 
            } 
        });

        // --- UPDATED handleCheck with refined animation timing and history saving ---
        function handleCheck(isSilent = false) {
            if (currentDailyState && currentDailyState.isComplete) return;
            if (!isSilent && state.checksRemaining <= 0) return;

            let checkPerformedThisTurn = false;
            // --- LOGIC FIX: Don't set firstCheckUsed here ---
            if (!isSilent && state.checksRemaining > 0) { // Check if checks are > 0 before decrementing
                checkPerformedThisTurn = true; // Mark that a user check was initiated
                // if (!state.firstCheckUsed) { state.firstCheckUsed = true; if (currentDailyState) currentDailyState.firstCheckUsed = true; } // <-- BUGGY, MOVED
                state.checksRemaining--;
                if (currentDailyState) currentDailyState.checksRemaining = state.checksRemaining;
                const lightToUse = CHECKS_AVAILABLE - state.checksRemaining - 1;
                if (lightToUse >= 0 && lightToUse < CHECKS_AVAILABLE) {
                    const lightElement = elements.lights.children[lightToUse];
                    if (lightElement) lightElement.classList.add('used');
                }
            } else if (!isSilent && state.checksRemaining <= 0) {
                 console.log("No checks remaining.");
                 return;
            }


            const flipDurationMs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--flip-duration') || '0.6') * 1000;
            const tileStaggerDelay = 100; // ms between each tile animation in a row
            let currentCheckRowStatuses = Array(7).fill('unchecked'); // Holds status for share grid
            let currentFirstTryBonus = 0;
            let rowsToCheck = []; // Array to hold { rowIndex, emptyTiles }
            let rowAnimationPromises = []; // --- RENAMED ---

            // Determine which rows are ready to be checked and populate currentCheckRowStatuses
            for (let i = 0; i < PUZZLE.stem.length; i++) {
                if (state.lockedRows.has(i)) {
                    currentCheckRowStatuses[i] = 'correct'; // Already correct
                    continue;
                }
                const emptyTiles = Array.from(document.querySelectorAll(`.grid-tile.empty[data-row='${i}']`));
                if (emptyTiles.length === 3 && emptyTiles.every(t => t.children.length > 0)) {
                    rowsToCheck.push({ rowIndex: i, emptyTiles });
                    if (!isSilent) emptyTiles.forEach(t => { if (t.children[0]) t.children[0].classList.remove('hint-correct', 'hint-present', 'hint-incorrect'); });
                } else {
                    // Inherit status from previous check if available
                    if (currentDailyState?.shareGridHistory?.length > 0) {
                        const lastHistory = currentDailyState.shareGridHistory[currentDailyState.shareGridHistory.length - 1];
                         if(lastHistory && lastHistory[i]) { currentCheckRowStatuses[i] = lastHistory[i]; } 
                         else { currentCheckRowStatuses[i] = 'unchecked'; }
                    } else { currentCheckRowStatuses[i] = 'unchecked'; }
                }
            }

            // If no rows are ready to check, but the button was pressed by the user
            if (rowsToCheck.length === 0 && checkPerformedThisTurn) {
                 console.log("Check pressed, but no rows were fully populated.");
                 if (currentDailyState) {
                     if (!Array.isArray(currentDailyState.shareGridHistory)) currentDailyState.shareGridHistory = [];
                     const checksUsedIndex = CHECKS_AVAILABLE - state.checksRemaining - 1;
                     if (checksUsedIndex >= 0 && currentDailyState.shareGridHistory.length === checksUsedIndex) {
                          currentDailyState.shareGridHistory.push([...currentCheckRowStatuses]); 
                          console.log("Pushed history for check (no rows evaluated):", checksUsedIndex + 1, currentCheckRowStatuses);
                     } else { console.warn(`History push mismatch (no rows evaluated). Index: ${checksUsedIndex}, History Length: ${currentDailyState.shareGridHistory.length}`); }
                 }
                 // --- LOGIC FIX: Set firstCheckUsed flag here too ---
                 if (!state.firstCheckUsed) { state.firstCheckUsed = true; if (currentDailyState) currentDailyState.firstCheckUsed = true; }
                 saveDailyState();
                 if (state.checksRemaining === 0 && state.lockedRows.size !== PUZZLE.stem.length) {
                    endGame(false, false); // Trigger loss if out of checks
                 }
                 return; // Exit check function
            }


            rowsToCheck.forEach(({ rowIndex, emptyTiles }) => {
                 // --- REFACTORED: Use Promise.all ---
                 let rowAnimationPromise = new Promise((resolveRow) => {
                    const i = rowIndex;
                    const sol = PUZZLE.solution[i];
                    let guess = Array(4).fill(''); guess[sol.stemIndex] = PUZZLE.stem[i];
                    emptyTiles.sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
                    let emptyIdx = 0; for(let k=0; k<4; k++) { if (k !== sol.stemIndex) { if (emptyTiles[emptyIdx]?.children[0]) guess[k] = emptyTiles[emptyIdx].children[0].textContent; emptyIdx++; } } guess = guess.join('');

                    const letterTilesInRow = emptyTiles.map(t => t.children[0]).filter(Boolean);
                    const stemTile = document.querySelector(`.grid-tile.stem-letter[data-row='${i}'] .letter-tile`);
                    const tileAnimationPromises = []; // Promises for each tile in *this* row

                    if (guess === sol.word) {
                        currentCheckRowStatuses[i] = 'correct';
                        // --- LOGIC FIX: Check firstCheckUsed flag *before* incrementing ---
                        if (!isSilent && state.firstCheckUsed === false) { 
                           currentFirstTryBonus += 150;
                        }

                        letterTilesInRow.forEach((tileElement, tileIndex) => {
                             const delay = tileIndex * tileStaggerDelay;
                             tileAnimationPromises.push(new Promise(resolveTile => {
                                 if (!isSilent) {
                                     setTimeout(() => {
                                         tileElement.classList.add('reveal');
                                         setTimeout(() => { tileElement.classList.remove('hint-present', 'hint-incorrect'); tileElement.classList.add('locked', 'hint-correct'); }, flipDurationMs / 2);
                                         tileElement.addEventListener('animationend', () => { tileElement.classList.remove('reveal'); resolveTile(); }, { once: true });
                                     }, delay);
                                 } else { 
                                     tileElement.classList.remove('hint-present', 'hint-incorrect'); 
                                     tileElement.classList.add('locked', 'hint-correct'); 
                                     resolveTile(); 
                                 }
                             }));
                        });
                        if(stemTile) {
                             tileAnimationPromises.push(new Promise(resolveStem => {
                                if (!isSilent) {
                                    const stemDelay = letterTilesInRow.length * tileStaggerDelay;
                                    setTimeout(() => {
                                         stemTile.classList.add('reveal');
                                         setTimeout(() => stemTile.classList.add('locked', 'hint-correct'), flipDurationMs / 2);
                                         stemTile.addEventListener('animationend', () => { stemTile.classList.remove('reveal'); resolveStem(); }, { once: true });
                                     }, stemDelay);
                                } else { 
                                    stemTile.classList.add('locked', 'hint-correct'); 
                                    resolveStem();
                                }
                            }));
                        }
                        state.lockedRows.add(i); 
                        if (currentDailyState && !currentDailyState.lockedRows.includes(i)) currentDailyState.lockedRows.push(i);

                    } else { // Incorrect word logic
                        let hasPresent = false; let hasIncorrect = false; const guessLetters=guess.split(''); const solutionLetters=sol.word.split(''); const tileHints=Array(4).fill(null); const solutionLetterUsed=Array(4).fill(false); solutionLetterUsed[sol.stemIndex]=true;
                        emptyTiles.forEach((tile)=>{const el=tile.children[0];if(!el)return;const l=el.textContent;let idx=0,gp=-1;for(let k=0;k<4;k++){if(k!==sol.stemIndex){if(tile===emptyTiles[idx]){gp=k;break;}idx++;}}if(gp!==-1&&l===solutionLetters[gp]){tileHints[gp]='hint-correct';solutionLetterUsed[gp]=true;}});
                        emptyTiles.forEach((tile)=>{const el=tile.children[0];if(!el)return;const l=el.textContent;let idx=0,gp=-1;for(let k=0;k<4;k++){if(k!==sol.stemIndex){if(tile===emptyTiles[idx]){gp=k;break;}idx++;}}if(gp!==-1&&tileHints[gp]!=='hint-correct'){let fo=false;for(let k=0;k<4;k++){if(k!==gp&&l===solutionLetters[k]&&!solutionLetterUsed[k]){tileHints[gp]='hint-present';solutionLetterUsed[k]=true;fo=true;hasPresent=true;break;}}if(!fo){tileHints[gp]='hint-incorrect';hasIncorrect=true;}}});

                        letterTilesInRow.forEach((tileElement, tileIndex) => {
                            let currentEmptyIdx = 0, hintPos = -1; const tileContainer = tileElement.parentElement; for(let k=0; k<4; k++) { if(k !== sol.stemIndex) { if (tileContainer === emptyTiles[currentEmptyIdx]) { hintPos = k; break; } currentEmptyIdx++; } } const hintClass = tileHints[hintPos] || 'hint-incorrect';
                            const delay = tileIndex * tileStaggerDelay;

                            tileAnimationPromises.push(new Promise(resolveTile => {
                                if (!isSilent) {
                                     setTimeout(() => {
                                         tileElement.classList.add('reveal');
                                         setTimeout(() => { tileElement.classList.remove('hint-correct', 'hint-present', 'hint-incorrect'); tileElement.classList.add(hintClass); }, flipDurationMs / 2);
                                         tileElement.addEventListener('animationend', () => { tileElement.classList.remove('reveal'); resolveTile(); }, { once: true });
                                     }, delay);
                                 } else { 
                                     tileElement.classList.remove('hint-correct', 'hint-present', 'hint-incorrect'); 
                                     tileElement.classList.add(hintClass); 
                                     resolveTile(); 
                                 }
                            }));
                        });

                        if(hasPresent) currentCheckRowStatuses[i] = 'present'; else currentCheckRowStatuses[i] = 'incorrect';
                    }
                    
                    // Wait for all tiles in this row to finish, then resolve the row promise
                    Promise.all(tileAnimationPromises).then(() => {
                        resolveRow();
                    });

                }); // End Promise constructor
                rowAnimationPromises.push(rowAnimationPromise);
            }); // End forEach rowToCheck

             // --- Actions after ALL promises resolve ---
             const finalActions = () => {
                 if (!isSilent && checkPerformedThisTurn) { // Only run if it was a user check
                     state.firstTryBonus += currentFirstTryBonus; // Add any bonus earned this check
                     
                     // --- LOGIC FIX: Set firstCheckUsed flag HERE ---
                     if (!state.firstCheckUsed) { 
                         state.firstCheckUsed = true; 
                         if (currentDailyState) currentDailyState.firstCheckUsed = true; 
                     }
                     // --- END LOGIC FIX ---


                     if (currentDailyState) {
                         if (!Array.isArray(currentDailyState.shareGridHistory)) currentDailyState.shareGridHistory = [];
                         const checksUsedIndex = CHECKS_AVAILABLE - state.checksRemaining -1;
                         if (checksUsedIndex >= 0 && currentDailyState.shareGridHistory.length === checksUsedIndex) {
                              for (let rowIdx = 0; rowIdx < 7; rowIdx++) {
                                  if (state.lockedRows.has(rowIdx)) {
                                      currentCheckRowStatuses[rowIdx] = 'correct'; 
                                  } else if (!rowsToCheck.some(r => r.rowIndex === rowIdx)) {
                                       const prevHistory = currentDailyState.shareGridHistory[checksUsedIndex - 1];
                                       currentCheckRowStatuses[rowIdx] = prevHistory?.[rowIdx] || 'unchecked';
                                  }
                              }
                              currentDailyState.shareGridHistory.push([...currentCheckRowStatuses]); 
                              console.log("Pushed history for check:", checksUsedIndex + 1, currentCheckRowStatuses);
                         } else {
                              console.warn(`History push mismatch. Index: ${checksUsedIndex}, History Length: ${currentDailyState.shareGridHistory.length}`);
                         }
                     }

                     saveDailyState(); // Save state AFTER hints applied and history updated

                     if (state.lockedRows.size === PUZZLE.stem.length) {
                         endGame(true, false);
                     } else if (state.checksRemaining === 0) { // Check if 0 checks left NOW
                         endGame(false, false);
                     }
                 }
             };

             // --- NEW: Wait for all ROW promises to resolve ---
             if (rowAnimationPromises.length > 0) {
                 Promise.all(rowAnimationPromises).then(() => {
                    // All row animations (or silent updates) are complete
                    if (!isSilent) {
                        setTimeout(finalActions, 50); // Small buffer just in case
                    }
                    // If silent, initGame will handle the endGame call
                 });
             } else if (checkPerformedThisTurn) {
                 // If no rows were checked but the button was pressed
                 finalActions();
             }
        }


        function endGame(isWin, isSilent = false) { elements.checkBtn.disabled = true; elements.practiceBtn.textContent = "Practice"; elements.modalTitle.textContent = isWin ? "Puzzle Solved!" : "Out of Checks!"; if (currentDailyState && !currentDailyState.statsRecorded) { updatePersistentStats(isWin); currentDailyState.statsRecorded = true; } if (currentDailyState) { currentDailyState.isComplete = true; saveDailyState(); } if (isWin) { elements.message.textContent = "Congratulations!"; document.querySelectorAll('.grid-tile.stem-letter').forEach(t => t.classList.add('stem-win')); } else { elements.message.textContent = "Out of checks!"; let sT = ""; for (let i = 0; i < PUZZLE.stem.length; i++) { if(PUZZLE.solution[i]) sT += `${PUZZLE.stem[i]} -> ${PUZZLE.solution[i].word}\n`; } if (elements.solutionTextEl) { elements.solutionTextEl.textContent = sT; elements.solutionDisplay.style.display = 'block'; } else elements.message.textContent = `Solution:\n${sT}`; } if (!isSilent) setTimeout(() => showEndGameStats(isWin), 1500); }
        function animateValue(element, start, end, duration, isBonus = false) { let startTimestamp = null; const step = (timestamp) => { if (!startTimestamp) startTimestamp = timestamp; const progress = Math.min((timestamp - startTimestamp) / duration, 1); if (element) { element.textContent = Math.floor(progress * (end - start) + start); if (progress >= 1) { element.textContent = end; if (isBonus) { element.textContent = `+${end}`; } } else { window.requestAnimationFrame(step); } } }; if (element) { if (isBonus && start === 0) { element.textContent = `+${start}`; } else { element.textContent = start; } window.requestAnimationFrame(step); } }
        
        // --- UPDATED: Scoring Rebalance ---
        function showEndGameStats(isWin) {
            const timeTaken = Math.round((Date.now() - state.startTime) / 1000);
            const minutes = Math.floor(timeTaken / 60);
            const seconds = timeTaken % 60;
            
            const pointsPerCheck = 150; // UPDATED from 100
            const checkBonus = state.checksRemaining * pointsPerCheck;
            
            const timeScore = Math.max(0, 600 - timeTaken) * 5; // UPDATED from 10
            
            const baseMoves = PUZZLE.stem.length * 3; 
            const pointsPerMoveSaved = 50; // UPDATED from 30
            const moveBonus = Math.max(0, baseMoves * 2 - state.moveCount) * pointsPerMoveSaved;

            const totalScore = isWin ? (timeScore + state.firstTryBonus + checkBonus + moveBonus) : 0;
            
            elements.finalTimeEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`; 
            elements.finalMovesEl.textContent = state.moveCount; 
            animateValue(elements.firstTryBonusEl, 0, state.firstTryBonus, 500, true); 
            animateValue(elements.checkBonusEl, 0, checkBonus, 500, true); 
            animateValue(elements.moveBonusEl, 0, moveBonus, 500, true); 
            animateValue(elements.finalScoreEl, 0, totalScore, 1000); 
            elements.endGameModalOverlay.classList.add('visible'); 
        }

        // --- UPDATED: Scoring Rebalance in Share ---
        function handleShare() {
            if (!currentDailyState || !currentDailyState.isComplete) { alert("Complete the daily puzzle!"); return; }
            let time = elements.finalTimeEl.textContent; let moves = elements.finalMovesEl.textContent; let score = elements.finalScoreEl.textContent;
            let checksUsed = CHECKS_AVAILABLE - state.checksRemaining;
            if (currentDailyState.shareGridHistory && currentDailyState.shareGridHistory.length > 0) {
                 checksUsed = currentDailyState.shareGridHistory.length;
            }

            if (time === '--:--') { const tT = Math.round((Date.now() - state.startTime) / 1000); time = `${Math.floor(tT / 60)}:${(tT % 60).toString().padStart(2, '0')}`; }
            if (moves === '--') moves = state.moveCount.toString();
            // Recalculate score if needed (e.g., share clicked before modal fully animated)
            if ((score === '0' || score === '--') && elements.finalScoreEl.textContent === '0' && state.lockedRows.size === PUZZLE.stem.length) { 
                const tT = Math.round((Date.now() - state.startTime) / 1000); 
                const cB = state.checksRemaining * 150; // UPDATED
                const tS = Math.max(0, 600 - tT) * 5; // UPDATED
                const bM = PUZZLE.stem.length * 3; 
                const mB = Math.max(0, bM * 2 - state.moveCount) * 50; // UPDATED
                score = (tS + state.firstTryBonus + cB + mB).toString(); 
            }

            const title = `Trellis #${currentDailyState.seed} - ${checksUsed}/${CHECKS_AVAILABLE} Checks`;
            let gridOutput = "";
            
            const isHighContrast = document.body.classList.contains('high-contrast');
            const statusToEmoji = {
                'correct': '', // Green
                'present': isHighContrast ? '' : '', // Blue or Orange
                'incorrect': '', // Red
                'unchecked': ''  // White/Grey
            };

            if (Array.isArray(currentDailyState.shareGridHistory)) {
                 currentDailyState.shareGridHistory.forEach(rowStatuses => {
                     if (Array.isArray(rowStatuses)) {
                         gridOutput += rowStatuses.map(status => statusToEmoji[status] || '').join('') + '\n';
                     }
                 });
            }

            const textToCopy = `${title}\n\n${gridOutput}\nTime: ${time} | Moves: ${moves} | Score: ${score}\n\nPlay Trellis: https://planomy.github.io/trellis`;
            copyUsingExecCommand(textToCopy);
        }

        function copyUsingExecCommand(textToCopy) { const textArea = document.createElement("textarea"); textArea.value = textToCopy; textArea.style.position = 'fixed'; textArea.style.left = '-9999px'; document.body.appendChild(textArea); textArea.select(); try { document.execCommand('copy'); elements.shareBtn.textContent = 'Copied!'; setTimeout(() => elements.shareBtn.textContent = 'Share', 2000); } catch (err) { console.error('Copy failed: ', err); elements.shareBtn.textContent = 'Copy Failed'; setTimeout(() => elements.shareBtn.textContent = 'Share', 2000); } document.body.removeChild(textArea); }
        function saveDailyState() { if (!currentDailyState) return; currentDailyState.moveCount = state.moveCount; currentDailyState.checksRemaining = state.checksRemaining; currentDailyState.lockedRows = Array.from(state.lockedRows); currentDailyState.firstCheckUsed = state.firstCheckUsed; if(!Array.isArray(currentDailyState.shareGridHistory)) currentDailyState.shareGridHistory = []; const board = []; document.querySelectorAll('.grid-tile.empty .letter-tile').forEach(t => board.push({ letter: t.textContent, location: 'grid', row: t.parentElement.dataset.row, col: t.parentElement.dataset.col })); document.querySelectorAll('.tray-tile .letter-tile').forEach(t => board.push({ letter: t.textContent, location: 'tray', index: t.parentElement.dataset.trayIndex })); currentDailyState.board = board; currentDailyState.isComplete = state.lockedRows.size === PUZZLE.stem.length || state.checksRemaining <= 0;
 currentDailyState.statsRecorded = currentDailyState.statsRecorded || false; try { localStorage.setItem(LS_KEYS.DAILY_STATE, JSON.stringify(currentDailyState)); } catch (e) { console.error("Save State Fail:", e); } }
        function loadDailyState(seed) { try { const saved = localStorage.getItem(LS_KEYS.DAILY_STATE); if (saved) { const loadedState = JSON.parse(saved); if (loadedState.seed === seed) { if (!Array.isArray(loadedState.lockedRows)) loadedState.lockedRows = []; if (loadedState.statsRecorded === undefined) loadedState.statsRecorded = loadedState.isComplete; if (!Array.isArray(loadedState.shareGridHistory)) loadedState.shareGridHistory = []; return loadedState; } else { clearDailyState(loadedState.seed); return null; } } } catch (e) { console.error("Load State Fail:", e); localStorage.removeItem(LS_KEYS.DAILY_STATE); return null; } return null; }
        function clearDailyState(seed) { try { const saved = localStorage.getItem(LS_KEYS.DAILY_STATE); if (saved) { const state = JSON.parse(saved); if (state.seed === seed) { localStorage.removeItem(LS_KEYS.DAILY_STATE); console.log("State cleared for " + seed); } } } catch(e) { console.error("Clear State Fail:", e); } }

        // --- UPDATED: Load settings on start ---
        loadSettings();
        applySettings(); // Apply them
        loadPersistentStats();
        elements.tagline.textContent = TAGLINES[Math.floor(Math.random() * TAGLINES.length)];

    });
    </script>
</body>
</html>
